<!DOCTYPE html>
<!-- VERSION 6.5 - iWATCH TV Client 2025-12-07 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iWATCH TV - Professional Streaming</title>
    <meta name="description" content="Professional IPTV streaming service with live TV, movies, and sports content">
    <meta name="author" content="iWATCH TV">
    <meta name="keywords" content="IPTV, streaming, live TV, movies, sports, entertainment">
    
    <!-- PWA Manifest for TV -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#7c3aed">
    <meta name="background-color" content="#0f0f23">
    
    <!-- App Icons - All TV Platforms -->
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
    
    <!-- Apple TV PWA -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="iWATCH TV">
    <link rel="apple-touch-startup-image" href="icon-1280x768.png">
    
    <!-- Microsoft / Xbox Tiles -->
    <meta name="msapplication-TileColor" content="#7c3aed">
    <meta name="msapplication-TileImage" content="icon-192.png">
    
    <!-- LG webOS TV Specific -->
    <meta name="webOS-app-id" content="com.iwatch.tv">
    <meta name="webOS-app-version" content="5.4">
    
    <!-- Samsung Tizen TV -->
    <meta name="tizen-app-id" content="iWATCHTV">
    
    <!-- Cursor/Pointer visibility for Smart Remotes -->
    <style>
        /* LG Magic Remote pointer optimization */
        * { cursor: pointer; }
        input, textarea { cursor: text; }
        
        /* Hover states for pointer mode (LG Magic Remote, Samsung) */
        .content-card:hover,
        .video-card:hover,
        .package-card:hover,
        .source-tab:hover,
        button:hover {
            outline: 3px solid #7c3aed !important;
            outline-offset: 2px !important;
            transform: scale(1.03);
            transition: all 0.15s ease;
        }
    </style>
    
    <!-- Remote Update System -->
    <script>
        // App Version Management
        const APP_CONFIG = {
            VERSION: '2.1.0',
            UPDATE_CHECK_INTERVAL: 60000, // Check for updates every 1 minute
            AUTO_UPDATE_ENABLED: true
        };

        // Remote Update System
        const updateSystem = {
            currentVersion: APP_CONFIG.VERSION,
            latestVersion: null,
            updateAvailable: false,
            updateData: null,
            
            // Check for updates
            async checkForUpdates() {
                try {
                    // Simulate checking for updates from admin panel
                    const updateManifest = this.getUpdateManifest();
                    
                    if (updateManifest && updateManifest.version !== this.currentVersion) {
                        this.latestVersion = updateManifest.version;
                        this.updateAvailable = true;
                        this.updateData = updateManifest;
                        
                        this.showUpdateNotification(updateManifest);
                        console.log(`ðŸ“± Update available: ${this.currentVersion} â†’ ${updateManifest.version}`);
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error('Update check failed:', error);
                    return false;
                }
            },
            
            // Get update manifest (simulates fetching from admin server)
            getUpdateManifest() {
                const savedManifest = localStorage.getItem('updateManifest');
                if (savedManifest) {
                    try {
                        return JSON.parse(savedManifest);
                    } catch (e) {
                        console.error('Invalid update manifest');
                    }
                }
                return null;
            },
            
            // Show update notification
            showUpdateNotification(manifest) {
                // Create update notification element
                const notification = document.createElement('div');
                notification.className = 'update-notification';
                notification.innerHTML = `
                    <div class="update-content">
                        <div class="update-icon">ðŸ“±</div>
                        <div class="update-info">
                            <h3>Update Available</h3>
                            <p>Version ${manifest.version} is ready to install</p>
                            <p class="update-description">${manifest.description || 'New features and improvements available'}</p>
                        </div>
                        <div class="update-actions">
                            <button onclick="updateSystem.installUpdate()" class="btn-update">Update Now</button>
                            <button onclick="updateSystem.dismissUpdate()" class="btn-dismiss">Later</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                // Auto-show update after 3 seconds if major update
                if (manifest.mandatory) {
                    setTimeout(() => {
                        notification.classList.add('show');
                    }, 3000);
                } else {
                    notification.classList.add('show');
                }
            },
            
            // Install update
            async installUpdate() {
                try {
                    const updateBtn = document.querySelector('.btn-update');
                    updateBtn.textContent = 'Installing...';
                    updateBtn.disabled = true;
                    
                    // Simulate update installation
                    await this.simulateUpdateInstallation();
                    
                    // Show success message
                    this.showUpdateSuccess();
                    
                    // Reload the page after successful update
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                    
                } catch (error) {
                    console.error('Update installation failed:', error);
                    this.showUpdateError();
                }
            },
            
            // Simulate update installation
            async simulateUpdateInstallation() {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        // Update local storage to mark as updated
                        localStorage.setItem('lastUpdateCheck', Date.now().toString());
                        localStorage.setItem('appVersion', this.updateData.version);
                        resolve();
                    }, 2000);
                });
            },
            
            // Dismiss update notification
            dismissUpdate() {
                const notification = document.querySelector('.update-notification');
                if (notification) {
                    notification.remove();
                }
                
                // Remind in 30 minutes for non-mandatory updates
                if (!this.updateData.mandatory) {
                    setTimeout(() => {
                        this.checkForUpdates();
                    }, 30 * 60 * 1000);
                }
            },
            
            // Show update success message
            showUpdateSuccess() {
                const notification = document.querySelector('.update-notification');
                if (notification) {
                    notification.innerHTML = `
                        <div class="update-success">
                            <div class="success-icon">âœ…</div>
                            <h3>Update Successful!</h3>
                            <p>Restarting application...</p>
                        </div>
                    `;
                    notification.classList.add('success');
                }
            },
            
            // Show update error message
            showUpdateError() {
                const updateBtn = document.querySelector('.btn-update');
                if (updateBtn) {
                    updateBtn.textContent = 'Update Failed';
                    updateBtn.disabled = false;
                }
                
                console.error('Update installation failed. Please try again.');
            },
            
            // Start automatic update checking
            startAutoUpdateCheck() {
                // Check immediately on startup
                this.checkForUpdates();
                
                // Set up periodic checking
                setInterval(() => {
                    this.checkForUpdates();
                }, APP_CONFIG.UPDATE_CHECK_INTERVAL);
            },
            
            // Manual update check (for settings menu)
            manualUpdateCheck() {
                return this.checkForUpdates();
            }
        };

        // Password Management System
        const passwordManager = {
            passwords: {
                // AUTO-LOGIN REMOVED - Each client must enter their own credentials
                'adminLogin': '',  // REMOVED: 'admin123'
                'resellerLogin': '',  // REMOVED: 'reseller123'
                'clientAdult': '8899',
                'panelAccess': '000000',
                'masterAdult': '273972' // Master password for admin emergency access to adult content
            },
            verifyPassword: function(key, input) {
                return this.passwords[key] === input;
            },
            authenticateUser: function(username, password) {
                // Load customer data from GitHub sync
                const customers = loadCustomersFromAdmin();
                
                // Find customer by username
                const customer = customers.find(c => c.username === username);
                
                // Check if customer exists and password matches
                if (customer && customer.password === password) {
                    // AUTOMATIC DEVICE LOCK - Silent Protection
                    // Generates unique device fingerprint and locks account to first device
                    // No admin setup needed - fully automatic - nobody knows why it fails
                    
                    // Generate or get this device's unique fingerprint
                    let deviceFingerprint = localStorage.getItem('iwatch_device_fp');
                    if (!deviceFingerprint) {
                        // Create unique fingerprint based on device characteristics
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        ctx.textBaseline = 'top';
                        ctx.font = '14px Arial';
                        ctx.fillText('iWatch-TV-Fingerprint', 2, 2);
                        const canvasData = canvas.toDataURL();
                        
                        const fpData = [
                            navigator.userAgent,
                            navigator.language,
                            screen.width + 'x' + screen.height,
                            screen.colorDepth,
                            new Date().getTimezoneOffset(),
                            navigator.hardwareConcurrency || 'unknown',
                            canvasData.slice(-50),
                            Date.now().toString(36)
                        ].join('|');
                        
                        // Create hash of fingerprint
                        let hash = 0;
                        for (let i = 0; i < fpData.length; i++) {
                            const char = fpData.charCodeAt(i);
                            hash = ((hash << 5) - hash) + char;
                            hash = hash & hash;
                        }
                        deviceFingerprint = 'DFP_' + Math.abs(hash).toString(36) + '_' + Date.now().toString(36);
                        localStorage.setItem('iwatch_device_fp', deviceFingerprint);
                    }
                    
                    // Check device lock for this customer
                    const lockKey = 'iwatch_lock_' + customer.id;
                    const lockTimeKey = 'iwatch_locktime_' + customer.id;
                    let storedFingerprint = localStorage.getItem(lockKey);
                    const lockTime = parseInt(localStorage.getItem(lockTimeKey) || '0');
                    
                    // Check if admin requested device reset (new TV scenario)
                    if (customer.resetDeviceLock && customer.resetDeviceLock > lockTime) {
                        // Admin reset the device lock - clear old lock and allow new device
                        localStorage.removeItem(lockKey);
                        localStorage.removeItem(lockTimeKey);
                        storedFingerprint = null;
                        console.log('Device lock reset by admin');
                    }
                    
                    if (!storedFingerprint) {
                        // FIRST LOGIN or RESET - Lock this account to this device automatically
                        localStorage.setItem(lockKey, deviceFingerprint);
                        localStorage.setItem(lockTimeKey, Date.now().toString());
                        console.log('Device locked for customer');
                    } else if (storedFingerprint !== deviceFingerprint) {
                        // DIFFERENT DEVICE - Block silently with generic error
                        // Don't reveal it's a device check - just say invalid credentials
                        console.log('Access denied');
                        return null; // Will show "Invalid credentials" - nobody knows why
                    }
                    
                    // Check if customer has active subscription
                    if (customer.status === 'active') {
                        // Check if subscription is not expired
                        let isValid = true;
                        if (customer.expiryDate) {
                            const expiryDate = new Date(customer.expiryDate);
                            const today = new Date();
                            isValid = expiryDate > today || customer.expiryDate.includes('T') === false;
                        }
                        
                        if (isValid) {
                            // Build subscribedPackages based on customer's plan and addons
                            const subscribedPackages = [];
                            const plan = customer.plan || '';
                            const addons = customer.addons || '';
                            
                            // Map plan to package IDs
                            if (plan.includes('Basic')) {
                                subscribedPackages.push('basicTV');
                            }
                            if (plan.includes('Second')) {
                                subscribedPackages.push('secondTV');
                            }
                            if (plan.includes('Third')) {
                                subscribedPackages.push('thirdTV');
                            }
                            
                            // Map addons to package IDs
                            if (addons.includes('Sports')) {
                                subscribedPackages.push('sports');
                            }
                            if (addons.includes('Movies')) {
                                subscribedPackages.push('movies');
                            }
                            if (addons.includes('Premium')) {
                                subscribedPackages.push('premium');
                            }
                            if (addons.includes('International')) {
                                subscribedPackages.push('international');
                            }
                            if (addons.includes('Adult')) {
                                subscribedPackages.push('adult');
                            }
                            
                            // Return customer object with subscription info
                            return {
                                username: customer.username,
                                fullName: customer.name, // Map admin's 'name' to client's expected 'fullName'
                                role: 'customer',
                                customerId: customer.id,
                                subscribedPackages: subscribedPackages,
                                subscriptionExpiry: customer.expiryDate, // Map admin's 'expiryDate' to client's expected 'subscriptionExpiry'
                                permissions: ['basic_access'], // Customer has basic access
                                plan: customer.plan,
                                addons: customer.addons,
                                adultPassword: customer.adultPassword || '8899'
                            };
                        }
                    }
                }
                
                return null; // No authentication found
            }
        };
    </script>
    
    <!-- Video.js CSS -->
    <link href="https://vjs.zencdn.net/8.12.0/video-js.css" rel="stylesheet">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --accent-blue: #667eea;
            --accent-purple: #764ba2;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --error-color: #f44336;
            --focus-color: #667eea;
            --adult-color: #ff4757;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-gradient);
            color: var(--text-primary);
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* Enable input field interaction */
        input, textarea, select {
            user-select: text !important;
            pointer-events: auto !important;
        }

        /* Keep UI elements non-selectable */
        .header, .sidebar, .player-area, .content-list, .category-grid {
            user-select: none;
            pointer-events: auto;
        }

        /* Allow text selection for input fields */
        input, textarea, select {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        /* Restrict selection for UI elements only */
        .header, .sidebar, .player-area, .content-list, .category-grid {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Header Styles - TV Fixed Positioning */
        .header {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 80px;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .logo-text {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header-info {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        /* User Status Styles */
        .user-status {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: var(--glass-bg);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .user-status:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        /* Logout Button Styles */
        .logout-btn {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: linear-gradient(135deg, #ff4757, #ff6b7a);
            border: none;
            border-radius: 20px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
        }

        .logout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 71, 87, 0.4);
            background: linear-gradient(135deg, #ff6b7a, #ff4757);
        }

        .logout-btn.show {
            display: flex;
        }

        .logout-btn svg {
            width: 18px;
            height: 18px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }

        .user-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .user-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .subscription-expiry {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .subscription-expiry.warning {
            color: var(--warning-color);
            font-weight: 600;
        }

        .subscription-expiry.expired {
            color: var(--error-color);
            font-weight: 600;
        }

        /* Time Display */
        .time-display {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .current-time {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .current-date {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Main Layout - TV Optimized */
        .main-container {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 30px;
            padding: 30px;
            margin-top: 80px; /* Account for fixed header */
            min-height: calc(100vh - 80px);
            position: relative;
            z-index: 1;
        }

        /* Sidebar Styles */
        .sidebar {
            background: var(--glass-bg);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            height: fit-content;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--accent-blue);
            border-bottom: 2px solid var(--accent-blue);
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Source Selection */
        .source-selector {
            margin-bottom: 25px;
        }

        .source-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 20px;
        }

        .source-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-secondary);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .source-tab.active {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
        }

        .source-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .source-tab.active:hover {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
        }

        /* Search Bar */
        .search-container {
            position: relative;
            margin-bottom: 25px;
        }

        .search-input {
            width: 100%;
            padding: 12px 45px 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            border-radius: 25px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--focus-color);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        /* Categories */
        .categories {
            margin-bottom: 30px;
        }

        .category-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .category-btn {
            background: var(--glass-bg);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
            padding: 12px 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .category-btn:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: var(--accent-blue);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
        }

        .category-btn.active {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            border-color: transparent;
            color: white;
            font-weight: 600;
        }

        .category-btn.adult {
            border-color: var(--adult-color);
        }

        .category-btn.adult:hover {
            background: rgba(255, 71, 87, 0.2);
            border-color: var(--adult-color);
        }

        .category-btn.adult.active {
            background: linear-gradient(135deg, var(--adult-color), #ff6b7a);
            color: white;
        }

        /* Adult Tab Styling */
        .source-tab.adult-tab {
            background: rgba(255, 71, 87, 0.1);
            border-color: var(--adult-color);
            color: var(--adult-color);
        }

        .source-tab.adult-tab:hover {
            background: rgba(255, 71, 87, 0.2);
            border-color: var(--adult-color);
        }

        .source-tab.adult-tab.active {
            background: linear-gradient(135deg, var(--adult-color), #ff6b7a);
            color: white;
        }

        /* Content List */
        .content-section {
            height: 400px;
            overflow: hidden;
        }

        .content-list {
            height: 100%;
            overflow-y: auto;
            padding-right: 10px;
        }

        .content-list::-webkit-scrollbar {
            width: 6px;
        }

        .content-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .content-list::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.6);
            border-radius: 3px;
        }

        .content-list::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }

        .content-item {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        /* Color-coded content types */
        .content-item.live-tv {
            border-left: 4px solid var(--warning-color);
        }

        .content-item.vod {
            border-left: 4px solid var(--success-color);
        }

        .content-item.internet {
            border-left: 4px solid var(--accent-blue);
        }

        /* Color-coded badges */
        .content-type-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .badge-live {
            background: var(--warning-color);
            color: white;
        }

        .badge-movies {
            background: var(--accent-purple);
            color: white;
        }

        .badge-vod {
            background: var(--success-color);
            color: white;
        }

        .badge-basic {
            background: var(--accent-blue);
            color: white;
        }

        .badge-addon {
            background: var(--focus-color);
            color: white;
        }

        .badge-internet {
            background: var(--accent-blue);
            color: white;
        }

        .badge-adult {
            background: #ff4757;
            color: white;
        }

        .content-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--accent-blue);
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.2);
        }

        .content-item.active {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            border-color: transparent;
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .content-item.adult-content {
            border-color: var(--adult-color);
        }

        .content-item.adult-content:hover {
            background: rgba(255, 71, 87, 0.1);
            border-color: var(--adult-color);
        }

        /* Package Authentication Styles */
        .content-item.locked-content {
            position: relative;
            opacity: 0.7;
            filter: grayscale(0.3);
            transition: all 0.3s ease;
        }

        .content-item.locked-content:hover {
            opacity: 0.8;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.2);
        }

        .lock-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 107, 107, 0.9);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .lock-icon {
            font-size: 16px;
            color: white;
        }

        /* Access Status Badges */
        .access-status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 8px;
            vertical-align: middle;
        }

        .access-status-badge.accessible {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        .access-status-badge.locked {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
            color: white;
        }

        /* Upgrade Modal Styles */
        .upgrade-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .content-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .content-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--glass-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-blue);
        }

        .content-info {
            flex: 1;
        }

        .content-name {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 3px;
        }

        .content-description {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .content-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            margin-top: 5px;
        }

        .live-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success-color);
            animation: pulse 2s infinite;
        }

        /* Streaming Mode Indicators */
        .streaming-indicator {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .streaming-indicator.always {
            background: #ff4444;
            color: white;
        }

        .streaming-indicator.on-demand {
            background: #666;
            color: white;
        }

        /* Main Player Area */
        .player-area {
            background: var(--glass-bg);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        /* Video Container */
        .video-container {
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            margin-bottom: 25px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
        }

        .video-player {
            width: 100%;
            height: 100%;
        }

        .video-js {
            border-radius: 15px;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.9), rgba(15, 52, 96, 0.9));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            border-radius: 15px;
            z-index: 10;
        }

        .video-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .play-button {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }

        .play-button:hover {
            transform: scale(1.1);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.6);
        }

        .play-icon {
            width: 0;
            height: 0;
            border-left: 35px solid white;
            border-top: 20px solid transparent;
            border-bottom: 20px solid transparent;
            margin-left: 8px;
        }

        .overlay-info {
            text-align: center;
        }

        .overlay-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #ffffff, #b0b0b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .overlay-description {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Now Playing Section */
        .now-playing {
            background: var(--glass-bg);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid var(--glass-border);
            margin-bottom: 25px;
        }

        .now-playing-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .now-playing-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-blue);
        }

        .quality-badge {
            background: linear-gradient(135deg, var(--success-color), #66bb6a);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
        }

        .now-playing-content {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 15px;
            align-items: center;
        }

        .content-avatar {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
        }

        .content-details {
            flex: 1;
        }

        .content-current {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .content-meta {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.4;
        }

        /* Video Controls */
        .video-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            background: var(--glass-bg);
            padding: 15px 20px;
            border-radius: 15px;
            border: 1px solid var(--glass-border);
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 80px;
        }

        .volume-display {
            min-width: 35px;
            text-align: center;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Login Modal - TV Interface Enhanced */
        .login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: flex-start; /* Changed for mobile scroll */
            z-index: 10000; /* Higher z-index for TV interface */
            animation: fadeIn 0.3s ease;
            overflow-y: auto; /* Enable scroll on mobile */
            padding: 20px 0; /* Add padding for scroll space */
        }

        .login-modal.show {
            display: flex;
        }

        .login-content {
            background: var(--primary-gradient);
            border-radius: 20px;
            padding: 40px;
            max-width: 400px;
            width: 90%;
            border: 1px solid var(--glass-border);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
            margin: auto; /* Center vertically when space available */
            flex-shrink: 0; /* Don't shrink on mobile */
        }

        .login-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .login-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: var(--accent-blue);
        }

        .login-subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .login-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-weight: 600;
            color: var(--text-primary);
        }

        .form-input {
            padding: 12px 16px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.3s ease;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            pointer-events: auto !important;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--focus-color);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .login-btn {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            color: white;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Checkbox styling for "Remember Me" */
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 14px;
            gap: 10px;
        }

        .checkbox-label input[type="checkbox"] {
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--accent-blue);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            outline: none;
        }

        .checkbox-label input[type="checkbox"]:checked {
            background: var(--accent-blue);
        }

        .checkbox-label input[type="checkbox"]:checked::after {
            content: 'âœ“';
            position: absolute;
            top: -2px;
            left: 3px;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        /* Adult Content Modal */
        .adult-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            animation: fadeIn 0.3s ease;
            pointer-events: none;
        }
        
        .adult-modal.show {
            display: flex;
            pointer-events: auto;
        }

        .adult-modal:not(.show) {
            pointer-events: none;
        }

        .adult-content {
            background: linear-gradient(135deg, #2c1810 0%, #1a0e08 50%, #0d0604 100%);
            border: 2px solid var(--adult-color);
            border-radius: 20px;
            padding: 40px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(255, 71, 87, 0.3);
            animation: slideUp 0.3s ease;
        }

        .adult-header {
            margin-bottom: 30px;
        }

        .adult-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--adult-color);
            margin-bottom: 10px;
        }

        .adult-warning {
            color: #ff9999;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        .adult-input {
            width: 200px;
            padding: 15px;
            font-size: 24px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--adult-color);
            border-radius: 10px;
            color: var(--adult-color);
            font-weight: bold;
            letter-spacing: 4px;
        }

        .adult-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .adult-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .adult-btn.confirm {
            background: var(--adult-color);
            color: white;
        }

        .adult-btn.cancel {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
        }

        /* Package Details Modal */
        .package-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
            pointer-events: none;
        }
        
        .package-modal.show {
            display: flex;
            pointer-events: auto;
        }
        
        .package-modal:not(.show) {
            pointer-events: none;
        }
        
        .package-content {
            background: var(--primary-gradient);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            padding: 0;
            max-width: 500px;
            min-width: 450px;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
            font-family: 'Arial', sans-serif;
        }
        
        .package-header {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
            padding: 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .package-title {
            color: white;
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .package-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 20px;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .package-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .package-info {
            padding: 25px;
        }
        
        .package-price-section {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .package-price {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 5px;
        }
        
        .package-duration {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }
        
        .package-status {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .package-status.status-active {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }
        
        .package-status.status-expired {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            color: #ffc107;
        }
        
        .package-status.status-inactive {
            background: rgba(158, 158, 158, 0.2);
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
        }
        
        .package-description, .package-features {
            margin-bottom: 20px;
        }
        
        .package-description h3, .package-features h3 {
            color: var(--text-primary);
            margin: 0 0 12px 0;
            font-size: 16px;
            font-weight: 600;
        }
        
        .package-description p {
            color: var(--text-secondary);
            line-height: 1.5;
            margin: 0;
            font-size: 14px;
        }
        
        .features-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .feature-item {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 14px;
            border-left: 3px solid var(--accent-color);
        }
        
        .package-actions {
            padding: 0 25px 25px 25px;
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        
        .package-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        .package-btn.subscribe {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
            color: white;
        }
        
        .package-btn.subscribe:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(var(--accent-rgb), 0.4);
        }
        
        .package-btn.close {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .package-btn.close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Adult Content Indicator */
        .adult-indicator {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .adult-indicator.locked {
            border-color: var(--adult-color);
        }

        .adult-indicator.unlocked {
            border-color: var(--success-color);
            background: rgba(76, 175, 80, 0.2);
        }

        .adult-icon {
            font-size: 18px;
        }

        .adult-status {
            font-size: 0.85rem;
            font-weight: 600;
        }

        .adult-indicator.locked .adult-status {
            color: var(--adult-color);
        }

        .adult-indicator.unlocked .adult-status {
            color: var(--success-color);
        }

        /* Responsive Design - TV Interface Optimized */
        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 20px;
                padding: 20px;
                margin-top: 80px; /* Keep header spacing */
            }
            
            .header {
                padding: 15px 20px;
                height: 70px; /* Smaller header on mobile/TV */
            }
            
            .logo-text {
                font-size: 2rem;
            }
            
            .header-info {
                gap: 15px;
            }
            
            .category-grid {
                grid-template-columns: 1fr;
            }
            
            /* TV Screen Specific Fixes */
            .header {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 1000 !important;
            }
            
            /* Login Modal Mobile Styles */
            .login-modal {
                padding: 10px;
                align-items: flex-start;
            }
            
            .login-content {
                padding: 25px;
                margin-top: 20px;
                margin-bottom: 20px;
            }
            
            .login-title {
                font-size: 1.5rem;
            }
            
            .form-input {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 14px 16px;
            }
            
            /* Package Modal Mobile Styles */
            .package-modal.show {
                padding: 10px;
            }
            
            .package-content {
                max-width: 95vw;
                min-width: auto;
                margin: 0 auto;
            }
            
            .package-header {
                padding: 15px;
            }
            
            .package-title {
                font-size: 20px;
            }
            
            .package-info {
                padding: 20px;
            }
            
            .package-price {
                font-size: 28px;
            }
            
            .package-actions {
                padding: 0 20px 20px 20px;
                flex-direction: column;
            }
            
            .package-btn {
                width: 100%;
            }
        }
        
        /* TV Large Screen Optimizations */
        @media (min-width: 1920px) {
            .main-container {
                max-width: 1600px;
                margin: 0 auto;
                margin-top: 80px;
            }
            
            .header {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 1000 !important;
            }
        }
            
            .video-container {
                height: 300px;
            }
            
            .now-playing-content {
                grid-template-columns: 1fr;
                text-align: center;
            }
            
            .video-controls {
                flex-wrap: wrap;
            }
            
            .volume-control {
                order: 3;
                width: 100%;
                justify-content: center;
            }
        }

        /* Loading States */
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }

        .error-message {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid var(--error-color);
            color: var(--error-color);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
        }

        .empty-message {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
        }

        .success-message {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid var(--success-color);
            color: var(--success-color);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
        }
    </style>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDmuXoHSGbJovbVz7wjqYSHITPjfolIHqw",
            authDomain: "iwatch-tv.firebaseapp.com",
            projectId: "iwatch-tv",
            storageBucket: "iwatch-tv.firebasestorage.app",
            messagingSenderId: "48651410266",
            appId: "1:48651410266:web:46f0c8d76a31e0e0c67163"
        };
        firebase.initializeApp(firebaseConfig);
        const fireDb = firebase.firestore();
        
        async function loadPlexFromFirebase() {
            try {
                const doc = await fireDb.collection('settings').doc('plex').get();
                if (doc.exists) {
                    const data = doc.data();
                    if (data.serverUrl) localStorage.setItem('plexServerUrl', data.serverUrl);
                    if (data.token) localStorage.setItem('plexToken', data.token);
                    if (data.moviesSection) localStorage.setItem('plexMoviesSection', data.moviesSection);
                    if (data.adultSection) localStorage.setItem('plexAdultSection', data.adultSection);
                    console.log('âœ… Loaded Plex settings from Firebase');
                    return true;
                }
            } catch(e) { console.log('Firebase load error:', e); }
            return false;
        }
        
        // Load customers from Firebase
        async function loadCustomersFromFirebase() {
            try {
                const doc = await fireDb.collection('customers').doc('main').get();
                if (doc.exists && doc.data().list) {
                    localStorage.setItem('adminCustomers', JSON.stringify(doc.data().list));
                    console.log('âœ… Loaded ' + doc.data().list.length + ' customers from Firebase');
                }
            } catch(e) { console.log('Firebase customers load error:', e); }
        }
        
        // Auto-load on page start
        loadPlexFromFirebase();
        loadCustomersFromFirebase();
    </script>

</head>
<body onload="initApp()">
    <!-- Header -->
    <header class="header">
        <div class="logo-section">
            <div class="logo-icon">ðŸ“º</div>
            <div class="logo-text">iWATCH TV</div>
        </div>
        
        <div class="header-info">
            <!-- Time Display -->
            <div class="time-display">
                <div class="current-time" id="timeDisplay">12:00:00</div>
                <div class="current-date" id="dateDisplay">Monday, November 17, 2025</div>
            </div>
            
            <!-- User Status -->
            <div class="user-status" onclick="showLoginModal()" id="userStatus">
                <div class="user-avatar">ðŸ‘¤</div>
                <div class="user-info">
                    <div class="user-name" id="userName">Guest</div>
                    <div class="subscription-expiry" id="subscriptionExpiry">Please Login</div>
                    <div class="subscription-packages" id="subscriptionPackages" style="font-size: 11px; color: var(--text-secondary); margin-top: 3px; display: none;"></div>
                </div>
            </div>
            
            <!-- Settings Button - Hidden, auto-sync enabled -->
            <!-- Sync button removed - data syncs automatically on startup -->
            
            <!-- Logout Button -->
            <button class="logout-btn" id="logoutBtn" onclick="logoutUser()">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                </svg>
                Logout
            </button>
            
            <!-- Adult Content Indicator -->
            <div class="adult-indicator locked" id="adultIndicator" style="display: none;" onclick="exitAdultContent()">
                <div class="adult-icon">ðŸ”’</div>
                <div class="adult-status">Locked</div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <main class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <h2 class="section-title">
                <span>ðŸŽ¬</span>
                Content Library
            </h2>
            
            <!-- Source Selection -->
            <div class="source-selector">
                <div class="source-tabs">
                    <button class="source-tab active" onclick="switchSource('live')" data-source="live">
                        ðŸ“º Live TV
                    </button>
                    <button class="source-tab" onclick="switchSource('sports-live')" data-source="sports-live" id="sportsLiveTab" style="display: none;">
                        âš½ Sports TV
                    </button>
                    <button class="source-tab" onclick="switchSource('livetv-addon')" data-source="livetv-addon" id="liveTvAddonTab" style="display: none;">
                        ðŸ“¡ TV Addon
                    </button>
                    <button class="source-tab" onclick="switchSource('movies')" data-source="movies">
                        ðŸŽ¬ Movies
                    </button>
                    <button class="source-tab" onclick="switchSource('vod')" data-source="vod">
                        ðŸ“€ VOD
                    </button>
                    <button class="source-tab" onclick="switchSource('basic')" data-source="basic">
                        ðŸ  Basic
                    </button>
                    <button class="source-tab" onclick="switchSource('addon')" data-source="addon">
                        ðŸ“¦ Addon
                    </button>
                    <!-- Adult tab - hidden by default, appears only when password is entered -->
                    <button class="source-tab adult-tab" onclick="switchSource('adult')" data-source="adult" id="adultTab" style="display: none;">
                        ðŸ”ž Adult
                    </button>
                    <button class="source-tab" onclick="switchSource('internet')" data-source="internet">
                        ðŸŒ Videos
                    </button>
                </div>
            </div>
            
            <!-- Search -->
            <div class="search-container">
                <input 
                    type="text" 
                    class="search-input" 
                    id="searchInput" 
                    placeholder="Search content..."
                    autocomplete="off"
                >
                <div class="search-icon">ðŸ”</div>
            </div>
            
            <!-- Categories -->
            <div class="categories">
                <h3 class="section-title">
                    <span>ðŸ“‹</span>
                    Categories
                </h3>
                <div class="category-grid" id="categoryGrid">
                    <!-- Categories will be populated by JavaScript -->
                </div>
            </div>
            
            <!-- Content List -->
            <div class="content-section">
                <div class="content-list" id="contentList">
                    <!-- Content items will be populated by JavaScript -->
                </div>
            </div>
        </aside>
        
        <!-- Player Area -->
        <section class="player-area">
            <!-- Video Player -->
            <div class="video-container">
                <video 
                    id="videoPlayer" 
                    class="video-player video-js vjs-default-skin" 
                    controls 
                    preload="auto"
                    poster=""
                ></video>
                
                <div class="video-overlay show" id="videoOverlay">
                    <div class="play-button" onclick="startPlaying()">
                        <div class="play-icon"></div>
                    </div>
                    <div class="overlay-info">
                        <h2 class="overlay-title">Welcome to iWATCH TV</h2>
                        <p class="overlay-description">Ready to watch! Login to access your content.</p>
                    </div>
                </div>
            </div>
            
            <!-- Now Playing -->
            <div class="now-playing">
                <div class="now-playing-header">
                    <h3 class="now-playing-title">Now Playing</h3>
                    <div class="quality-badge">HD Quality</div>
                </div>
                <div class="now-playing-content" id="nowPlayingContent">
                    <div class="content-avatar">ðŸ“º</div>
                    <div class="content-details">
                        <div class="content-current">No content selected</div>
                        <div class="content-meta">Login and select content to start watching</div>
                    </div>
                </div>
            </div>
            
            <!-- Video Controls -->
            <div class="video-controls">
                <button class="control-btn" onclick="togglePlay()">â–¶ï¸ Play/Pause</button>
                <button class="control-btn" onclick="toggleFullscreen()">â›¶ Fullscreen</button>
                <button class="control-btn" onclick="toggleMute()">ðŸ”Š Mute/Unmute</button>
                <button class="control-btn" onclick="stopStream()">â¹ï¸ Stop</button>
                
                <div class="volume-control">
                    <span>ðŸ”Š</span>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
                    <span class="volume-display" id="volumeDisplay">50%</span>
                </div>
            </div>
        </section>
    </main>

    <!-- Login Modal -->
    <div class="login-modal" id="loginModal">
        <div class="login-content">
            <div class="login-header">
                <h2 class="login-title">ðŸ” Login</h2>
                <p class="login-subtitle">Access your iWATCH TV account</p>
                <p style="color: var(--text-secondary); font-size: 12px; margin-top: 10px;">
                    ðŸ’¡ Check "Remember me" to auto-login until subscription expires
                </p>
            </div>
            
            <form class="login-form" id="loginForm" autocomplete="off">
                <div class="form-group">
                    <label class="form-label">Username</label>
                    <input type="text" class="form-input" id="username" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Password</label>
                    <input type="password" class="form-input" id="password" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="rememberMe" checked>
                        <span class="checkmark"></span>
                        Remember me on this TV
                    </label>
                </div>
                
                <button type="submit" class="login-btn" id="loginBtn">Login</button>
            </form>
            
            <div class="error-message" id="errorMessage" style="display: none;">
                Invalid username or password. Please try again.
            </div>
        </div>
    </div>

    <!-- Adult Content Modal -->
    <div class="adult-modal" id="adultModal">
        <div class="adult-content">
            <div class="adult-header">
                <h2 class="adult-title">ðŸ”ž</h2>
                <p class="adult-warning">Adult Content Verification Required</p>
                <p class="adult-warning">You must be 18+ to access this content</p>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: var(--text-primary);">Enter Password:</label>
                <input type="password" class="adult-input" id="adultPassword" maxlength="6" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢">
            </div>
            
            <div class="adult-buttons">
                <button class="adult-btn confirm" onclick="verifyAdultPassword()">âœ… Verify</button>
                <button class="adult-btn cancel" onclick="hideAdultModal()">âŒ Cancel</button>
            </div>
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="showChangeAdultPassword()" style="background: transparent; border: none; color: #888; font-size: 12px; cursor: pointer; text-decoration: underline;">Change Password</button>
            </div>
        </div>
    </div>
    
    <!-- Change Adult Password Modal -->
    <div class="adult-modal" id="changeAdultPasswordModal">
        <div class="adult-content">
            <div class="adult-header">
                <h2 class="adult-title">ðŸ”</h2>
                <p class="adult-warning">Change Adult Password</p>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: var(--text-primary); font-size: 13px;">Current Password:</label>
                <input type="password" class="adult-input" id="currentAdultPass" maxlength="6" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢">
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: var(--text-primary); font-size: 13px;">New Password:</label>
                <input type="password" class="adult-input" id="newAdultPass" maxlength="6" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢">
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: var(--text-primary); font-size: 13px;">Confirm New Password:</label>
                <input type="password" class="adult-input" id="confirmAdultPass" maxlength="6" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢">
            </div>
            <div class="adult-buttons">
                <button class="adult-btn confirm" onclick="changeAdultPassword()">âœ… Save</button>
                <button class="adult-btn cancel" onclick="hideChangeAdultPassword()">âŒ Cancel</button>
            </div>
        </div>
    </div>

    <!-- Package Details Modal -->
    <div class="package-modal" id="packageModal">
        <div class="package-content">
            <div class="package-header">
                <h2 class="package-title" id="packageTitle">ðŸ“¦ Package Details</h2>
                <button class="package-close" onclick="hidePackageDetails()">âŒ</button>
            </div>
            
            <div class="package-info">
                <div class="package-price-section">
                    <div class="package-price" id="packagePrice">$0/month</div>
                    <div class="package-duration" id="packageDuration">Monthly</div>
                </div>
                
                <div class="package-status" id="packageStatus">
                    <span class="status-inactive">ðŸ“¦ Not Subscribed</span>
                </div>
                
                <div class="package-description">
                    <h3>Description</h3>
                    <p id="packageDescription">Package description will be displayed here</p>
                </div>
                
                <div class="package-features">
                    <h3>Features</h3>
                    <div class="features-list" id="packageFeatures">
                        <div class="feature-item">ðŸ“‹ Features will be displayed here</div>
                    </div>
                </div>
            </div>
            
            <div class="package-actions">
                <button class="package-btn subscribe" onclick="subscribeToPackage()" style="display: none;">ðŸ’³ Subscribe Now</button>
                <button class="package-btn close" onclick="hidePackageDetails()">ðŸ‘ Close</button>
            </div>
        </div>
    </div>

    <!-- Video.js JavaScript -->
    <script src="https://vjs.zencdn.net/8.12.0/video.min.js"></script>
    
    <!-- HLS.js for live streaming -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <script>
        console.log('ðŸŽ¬ðŸŽ¬ðŸŽ¬ CLIENT V5.3 LOADED - ENHANCED PLEX DEBUG ðŸŽ¬ðŸŽ¬ðŸŽ¬');
        
        // Global Variables
        let player = null;
        let hls = null;
        let isLoggedIn = false;
        let currentUser = null;
        let currentSource = 'live';
        let currentCategory = 'all';
        let adultUnlocked = false;
        let currentContent = null;
        let adultTypingSequence = '';
        let typingTimeout = null;
        let adminCustomers = [];

        // Enhanced Package Authentication System for Client Interface
        const clientPackageAuth = {
            // GUARANTEED to be initialized as empty object from the very beginning
            mappings: {},
            
            // Ensure mappings is ALWAYS available before any function calls
            ensureMappingsInitialized: function() {
                if (!this.mappings || typeof this.mappings !== 'object') {
                    this.mappings = {};
                }
                return this.mappings;
            },
            
            // Load package content mappings from admin panel with GUARANTEED initialization
            loadPackageMappings: function() {
                try {
                    // Ensure mappings object exists FIRST
                    this.ensureMappingsInitialized();
                    
                    const mappings = localStorage.getItem('packageContentMappings');
                    if (mappings) {
                        this.mappings = JSON.parse(mappings);
                        console.log('ðŸ“¦ Loaded package content mappings:', Object.keys(this.mappings).length);
                    } else {
                        this.mappings = {};
                        console.log('ðŸ“¦ No package content mappings found, initialized empty');
                    }
                    return this.mappings;
                } catch (e) {
                    console.error('âŒ Error loading package mappings:', e);
                    this.mappings = {};
                    return {};
                }
            },

            // Get package mapping for a specific package
            getPackageMapping: function(packageId) {
                // GUARANTEED mappings initialization BEFORE any access
                this.ensureMappingsInitialized();
                
                if (!packageId) {
                    console.warn('âš ï¸ getPackageMapping called with undefined packageId');
                    return null;
                }
                
                try {
                    const mapping = this.mappings[packageId];
                    console.log(`ðŸ” Get package mapping for '${packageId}':`, mapping);
                    return mapping || null;
                } catch (e) {
                    console.error('âŒ Error accessing mappings:', e);
                    this.mappings = {}; // Reset to safe state
                    return null;
                }
            },

            // SIMPLIFIED: Validate if customer has access to specific package
            validatePackageAccess: function(customer, packageId) {
                // Get package data
                const packageData = adminPackages.find(p => p.id === packageId);
                if (!packageData) {
                    return { hasAccess: false, reason: 'Package not found' };
                }

                const pkgName = (packageData.name || '').toLowerCase();
                const customerAddons = (customer.addons || '').toLowerCase();
                
                // Check subscription expiry first
                if (customer.expiryDate) {
                    const expiryDate = new Date(customer.expiryDate);
                    const today = new Date();
                    if (expiryDate <= today) {
                        return { hasAccess: false, reason: 'Subscription expired' };
                    }
                }

                // ADULT content - requires explicit Adult addon
                if (packageData.isAdult || pkgName.includes('adult')) {
                    if (!customerAddons.includes('adult')) {
                        return { hasAccess: false, reason: 'Adult addon required' };
                    }
                    return { hasAccess: true };
                }

                // SPECIAL packages (World Cup, Premium events) - require specific addon
                const specialKeywords = ['world cup', 'premium', 'exclusive', 'ppv', 'pay per view'];
                const isSpecialPackage = specialKeywords.some(kw => pkgName.includes(kw));
                
                if (isSpecialPackage) {
                    // Check if customer has this specific addon
                    if (customerAddons.includes(pkgName) || customerAddons.includes(packageData.name.toLowerCase())) {
                        return { hasAccess: true };
                    }
                    // Also check for partial match (e.g., "World Cup" addon for "World Cup 2024" package)
                    const addonWords = customerAddons.split(',').map(a => a.trim());
                    for (let addon of addonWords) {
                        if (addon && pkgName.includes(addon)) {
                            return { hasAccess: true };
                        }
                    }
                    return { hasAccess: false, reason: 'Special package addon required: ' + packageData.name };
                }

                // REGULAR packages - all subscribed customers can access
                if (customer.status === 'active' || customer.plan) {
                    return { hasAccess: true };
                }

                return { hasAccess: false, reason: 'Active subscription required' };
            },

            // SIMPLIFIED: Get all accessible packages for current customer
            getAccessiblePackages: function() {
                // Reload fresh data
                const packagesRaw = localStorage.getItem('adminPackages');
                const customersRaw = localStorage.getItem('adminCustomers');
                
                console.log('ðŸ“¦ RAW localStorage adminPackages:', packagesRaw ? packagesRaw.substring(0, 200) : 'NULL');
                
                adminPackages = JSON.parse(packagesRaw || '[]');
                adminCustomers = JSON.parse(customersRaw || '[]');
                
                console.log('ðŸ“¦ Loaded packages count:', adminPackages.length);
                console.log('ðŸ“¦ Package names:', adminPackages.map(p => p.name));
                
                if (!currentUser || !currentUser.username) {
                    console.log('ðŸ“¦ No user logged in');
                    return [];
                }

                // Admin gets all packages
                if (currentUser.role === 'admin') {
                    console.log('ðŸ“¦ Admin access - all packages available');
                    return adminPackages.map(pkg => ({ package: pkg, validation: { hasAccess: true } }));
                }

                const customer = adminCustomers.find(c => c.username === currentUser.username);
                if (!customer) {
                    console.log('ðŸ“¦ Customer not found:', currentUser.username);
                    return [];
                }

                console.log('ðŸ“¦ Checking access for customer:', customer.name, '| Plan:', customer.plan, '| Addons:', customer.addons);

                const accessiblePackages = [];
                
                adminPackages.forEach(pkg => {
                    const validation = this.validatePackageAccess(customer, pkg.id);
                    console.log(`  - Package "${pkg.name}": ${validation.hasAccess ? 'âœ…' : 'âŒ'} ${validation.reason || ''}`);
                    if (validation.hasAccess) {
                        accessiblePackages.push({
                            package: pkg,
                            validation: validation
                        });
                    }
                });

                console.log('ðŸ“¦ Total accessible packages:', accessiblePackages.length);
                return accessiblePackages;
            },

            // Filter content based on package authentication
            filterContentByAuth: function(content, currentSource) {
                if (!currentUser || !currentUser.username) {
                    return content.filter(item => !item.requiresPackage); // Show demo content only
                }

                const customer = adminCustomers.find(c => c.username === currentUser.username);
                if (!customer) {
                    return [];
                }

                return content.filter(item => {
                    // If content doesn't require a package, show it
                    if (!item.requiresPackage) {
                        return true;
                    }

                    // Check if customer has access to required package
                    const validation = this.validatePackageAccess(customer, item.requiresPackage);
                    return validation.hasAccess;
                });
            },

            // Get content libraries for customer's packages
            getCustomerLibraries: function() {
                const accessiblePackages = this.getAccessiblePackages();
                const allLibraries = new Set();

                accessiblePackages.forEach(({ validation }) => {
                    if (validation.libraries) {
                        validation.libraries.forEach(library => allLibraries.add(library));
                    }
                });

                return Array.from(allLibraries);
            },

            // SIMPLIFIED: Check if customer can access adult content
            canAccessAdult: function() {
                if (!currentUser) return false;
                
                // Admin always has access
                if (currentUser.role === 'admin') return true;

                // Check customer's addons for Adult
                const customer = adminCustomers.find(c => c.username === currentUser.username);
                if (!customer) return false;

                const addons = (customer.addons || '').toLowerCase();
                return addons.includes('adult');
            },

            // SIMPLIFIED: Check if customer can access specific content
            canAccessContent: function(contentItem) {
                if (!currentUser || !contentItem) return false;

                // Admin always has access
                if (currentUser.role === 'admin') return true;

                // Reload customer data
                adminCustomers = JSON.parse(localStorage.getItem('adminCustomers') || '[]');
                const customer = adminCustomers.find(c => c.username === currentUser.username);
                if (!customer) return false;

                // Check subscription expiry
                if (customer.expiryDate) {
                    const expiryDate = new Date(customer.expiryDate);
                    if (expiryDate <= new Date()) return false;
                }

                // Adult content check
                if (contentItem.isAdult || (contentItem.category || '').toLowerCase().includes('adult')) {
                    return this.canAccessAdult();
                }

                // If content requires specific package, check it
                if (contentItem.requiresPackage || contentItem.packageId) {
                    const pkgId = contentItem.requiresPackage || contentItem.packageId;
                    const validation = this.validatePackageAccess(customer, pkgId);
                    return validation.hasAccess;
                }

                // Regular content - allow if customer has active subscription
                return customer.status === 'active' || !!customer.plan;
            },

            // Real-time authentication updates
            setupRealTimeUpdates: function() {
                window.addEventListener('storage', (e) => {
                    if (e.key === 'packageContentMappings') {
                        console.log('ðŸ”„ Package mappings updated, refreshing client auth...');
                        this.loadPackageMappings();
                        this.refreshContentAccess();
                    }
                    
                    if (e.key === 'packageAuthBroadcast') {
                        const updateData = JSON.parse(e.newValue);
                        if (updateData.source === 'admin_panel') {
                            console.log('ðŸ“¡ Received auth broadcast:', updateData);
                            this.handleAuthUpdate(updateData);
                        }
                    }

                    if (e.key === 'adminPackages') {
                        console.log('ðŸ”„ Packages updated, refreshing auth validation...');
                        this.refreshContentAccess();
                    }

                    if (e.key === 'adminCustomers') {
                        console.log('ðŸ‘¥ Customer data updated, refreshing auth validation...');
                        this.refreshContentAccess();
                    }
                });
            },

            // Handle authentication updates from admin panel
            handleAuthUpdate: function(updateData) {
                switch (updateData.action) {
                    case 'mapping_created':
                    case 'mapping_updated':
                    case 'mapping_removed':
                        this.loadPackageMappings();
                        this.refreshContentAccess();
                        showNotification(`ðŸ” Package authentication updated: ${updateData.action.replace('_', ' ')}`, 'info');
                        break;
                    default:
                        console.log('Unknown auth update:', updateData.action);
                }
            },

            // Refresh content access based on current authentication
            refreshContentAccess: function() {
                // Re-render current content with new authentication
                if (typeof renderContent === 'function') {
                    renderContent();
                }

                // Update adult content visibility
                if (this.canAccessAdult()) {
                    showAdultTab();
                } else {
                    hideAdultTab();
                    adultUnlocked = false;
                    hideAdultIndicator();
                }

                console.log('âœ… Content access refreshed based on authentication');
            },

            // Initialize the client authentication system
            initialize: function() {
                console.log('ðŸ” Initializing Client Package Authentication...');
                
                // Load all required data first
                this.loadPackageMappings();
                
                // Ensure admin data is loaded
                adminPackages = localStorage.getItem('adminPackages') ? JSON.parse(localStorage.getItem('adminPackages')) : [];
                adminCustomers = localStorage.getItem('adminCustomers') ? JSON.parse(localStorage.getItem('adminCustomers')) : [];
                
                // Setup real-time updates
                this.setupRealTimeUpdates();
                
                console.log('âœ… Client Package Authentication ready:', {
                    mappings: Object.keys(this.mappings || {}).length,
                    packages: adminPackages.length,
                    customers: adminCustomers.length
                });
            }
        };

        // Initialize client authentication system
        clientPackageAuth.initialize();
        
        // Test the getPackageMapping function immediately
        setTimeout(() => {
            try {
                console.log('ðŸ§ª Testing getPackageMapping function...');
                const testMapping = clientPackageAuth.getPackageMapping('basic-monthly');
                console.log('âœ… getPackageMapping test passed, result:', testMapping);
            } catch (e) {
                console.error('âŒ getPackageMapping test failed:', e);
            }
        }, 100);
        
        // Initialize basic package mappings for existing packages (fallback)
        function initializeBasicPackageMappings() {
            try {
                const adminPackages = localStorage.getItem('adminPackages');
                if (adminPackages) {
                    const packages = JSON.parse(adminPackages);
                    const existingMappings = localStorage.getItem('packageContentMappings');
                    
                    if (!existingMappings) {
                        // Create basic mappings for Movies and Adult packages
                        const basicMappings = {};
                        packages.forEach(pkg => {
                            if (pkg && pkg.id) {
                                basicMappings[pkg.id] = {
                                    packageId: pkg.id,
                                    packageName: pkg.name,
                                    contentMapping: {
                                        movies: pkg.name.toLowerCase().includes('movie') || pkg.type === 'movies',
                                        adult: pkg.name.toLowerCase().includes('adult') || pkg.type === 'adult',
                                        live: pkg.type === 'basic',
                                        sports: pkg.name.toLowerCase().includes('sport')
                                    },
                                    active: true,
                                    createdDate: new Date().toISOString(),
                                    libraries: pkg.libraries || []
                                };
                            }
                        });
                        
                        localStorage.setItem('packageContentMappings', JSON.stringify(basicMappings));
                        clientPackageAuth.loadPackageMappings(); // Reload mappings
                        console.log('ðŸ“¦ Created basic package mappings for', Object.keys(basicMappings).length, 'packages');
                    }
                }
            } catch (error) {
                console.error('âŒ Error initializing basic package mappings:', error);
            }
        }
        
        // Initialize basic mappings immediately
        initializeBasicPackageMappings();
        // Initialize basic mappings after a short delay
        setTimeout(initializeBasicPackageMappings, 1000);

        // Debug function to check package authentication status
        // Make debugPackageAuth IMMEDIATELY accessible from console
        function debugPackageAuth() {
            console.log('ðŸ” Package Authentication Debug Info:');
            console.log('- adminPackages:', adminPackages?.length || 0, 'packages');
            console.log('- adminCustomers:', adminCustomers?.length || 0, 'customers');
            console.log('- currentUser:', currentUser?.username || 'none');
            console.log('- mappings:', clientPackageAuth.mappings || {});
            console.log('- mappings keys:', Object.keys(clientPackageAuth.mappings || {}));
            console.log('- accessible packages:', clientPackageAuth.getAccessiblePackages()?.length || 0);
            
            // Test getPackageMapping with various package IDs
            const testIds = ['basic-monthly', 'movies', 'adult'];
            testIds.forEach(id => {
                try {
                    const mapping = clientPackageAuth.getPackageMapping(id);
                    console.log(`ðŸ“¦ Mapping test for '${id}':`, mapping ? 'âœ… Found' : 'âŒ Not found');
                } catch (e) {
                    console.error(`âŒ Error testing mapping for '${id}':`, e);
                }
            });
            
            // Check localStorage
            const storedPackages = localStorage.getItem('adminPackages');
            const storedMappings = localStorage.getItem('packageContentMappings');
            console.log('- storedPackages exists:', !!storedPackages);
            console.log('- storedMappings exists:', !!storedMappings);
            
            if (storedPackages) {
                try {
                    const packages = JSON.parse(storedPackages);
                    console.log('- stored packages count:', packages.length);
                    console.log('- first few packages:', packages.slice(0, 3));
                } catch (e) {
                    console.log('- error parsing stored packages:', e);
                }
            }
        };
        
        // Also define it at module level for immediate access
        // Ensure debugPackageAuth is available both as function and window property
        var debugPackageAuth = debugPackageAuth;
        window.debugPackageAuth = debugPackageAuth;
        
        // Also make clientPackageAuth available globally for debugging
        window.clientPackageAuth = clientPackageAuth;
        
        console.log('ðŸ”§ Debug functions initialized - debugPackageAuth() and window.clientPackageAuth available');
        
        // IMMEDIATE TEST: Verify mappings initialization
        console.log('ðŸ§ª IMMEDIATE TEST - Testing mappings initialization:');
        console.log('- clientPackageAuth.mappings exists:', !!clientPackageAuth.mappings);
        console.log('- mappings is object:', typeof clientPackageAuth.mappings === 'object');
        console.log('- test getPackageMapping call result:', clientPackageAuth.getPackageMapping('test'));
        console.log('- debugPackageAuth available:', typeof debugPackageAuth === 'function');
        console.log('ðŸ§ª END IMMEDIATE TEST');

        // Call debug function if there's an error
        window.addEventListener('error', (e) => {
            if (e.message.includes('basic-monthly') || e.message.includes('getPackageMapping')) {
                console.error('ðŸ”§ Package authentication error detected, running debug...');
                setTimeout(debugPackageAuth, 500);
            }
        });

        // Enhanced Load packages from admin panel with authentication integration
        function loadPackagesFromAdmin() {
            try {
                // GUARANTEED mappings initialization BEFORE any access
                clientPackageAuth.ensureMappingsInitialized();
                
                const adminPackages = localStorage.getItem('adminPackages');
                if (adminPackages) {
                    const packages = JSON.parse(adminPackages);
                    console.log('ðŸ” Debug - loadPackagesFromAdmin called with', packages.length, 'packages');
                    
                    // Apply authentication filtering to packages
                    const authenticatedPackages = packages.map(pkg => {
                        let mapping = null;
                        try {
                            if (pkg && pkg.id) {
                                // Ensure mappings are ALWAYS initialized before getting mapping
                                clientPackageAuth.ensureMappingsInitialized();
                                mapping = clientPackageAuth.getPackageMapping(pkg.id);
                            }
                        } catch (e) {
                            console.warn('âš ï¸ Error getting package mapping for:', pkg?.id || 'unknown', e);
                            // On error, reset mappings to safe state
                            clientPackageAuth.mappings = {};
                        }
                        const hasMapping = mapping && mapping.active;
                        
                        return {
                            id: pkg.id || 'PKG_' + Date.now(),
                            name: pkg.name,
                            description: pkg.features || `Package - $${pkg.price}/${pkg.duration}`,
                            category: pkg.type || 'addon',
                            adult: pkg.isAdult || false,
                            type: 'package',
                            packageId: pkg.id,
                            price: pkg.price,
                            duration: pkg.duration,
                            adultPrice: pkg.adultPackagePrice || 0,
                            streamingMode: pkg.isAdult ? 'on-demand' : 'on-demand',
                            hasContentMapping: hasMapping, // Flag for UI
                            accessLevel: mapping?.contentMapping?.accessLevel || 1
                        };
                    }).filter(pkg => {
                        // Show all packages to logged-in users for subscription display
                        // Content access is checked separately when playing content
                        if (!currentUser) {
                            return false; // Not logged in - hide packages
                        }
                        return true; // Show all packages to logged-in users
                    });

                    console.log(`ðŸ“¦ Loaded ${authenticatedPackages.length} authenticated packages from admin panel`);
                    return authenticatedPackages;
                }
            } catch (e) {
                console.error('Error loading packages from admin:', e);
            }
            return [];
        }

        // Load all packages from admin panel (including libraries)
        function loadAllPackagesFromAdmin() {
            try {
                const adminPackages = localStorage.getItem('adminPackages');
                if (adminPackages) {
                    return JSON.parse(adminPackages);
                }
            } catch (e) {
                console.error('Error loading packages from admin:', e);
            }
            return [];
        }

        // Load customers from admin panel (now uses correct key)
        function loadCustomersFromAdmin() {
            try {
                const adminCustomers = localStorage.getItem('adminCustomers');
                if (adminCustomers) {
                    return JSON.parse(adminCustomers);
                }
            } catch (e) {
                console.error('Error loading customers from admin:', e);
            }
            return [];
        }

        // Auto-login functionality for TV platform
        function checkAutoLogin() {
            try {
                // Check for stored credentials
                const storedCredentials = localStorage.getItem('iwatch_tv_credentials');
                const storedExpiry = localStorage.getItem('iwatch_tv_expiry');
                
                if (storedCredentials && storedExpiry) {
                    const credentials = JSON.parse(storedCredentials);
                    const expiryDate = new Date(storedExpiry);
                    const currentDate = new Date();
                    
                    // Check if subscription is still valid
                    if (currentDate < expiryDate) {
                        console.log('ðŸ”‘ Auto-login: Found valid credentials, logging in...');
                        
                        // Find customer in database
                        const customer = adminCustomers.find(c => 
                            c.username === credentials.username && c.password === credentials.password);
                        
                        if (customer) {
                            // Auto-login
                            const userData = {
                                username: customer.username,
                                customerId: customer.id,
                                loginTime: new Date().toISOString()
                            };
                            
                            currentUser = userData;
                            isLoggedIn = true;
                            
                            updateUserInterface();
                            console.log(`âœ… Auto-login successful for ${customer.username}`);
                            return;
                        } else {
                            console.log('âŒ Auto-login: Stored credentials not found in database');
                            clearStoredCredentials();
                        }
                    } else {
                        console.log('â° Auto-login: Subscription expired, clearing stored credentials');
                        clearStoredCredentials();
                    }
                }
            } catch (error) {
                console.error('âŒ Auto-login error:', error);
                clearStoredCredentials();
            }
        }
        
        // Store credentials securely
        function storeCredentials(username, password, expiryDate, rememberMe) {
            if (!rememberMe) return; // Only store if "Remember Me" is checked
            
            const credentials = {
                username: username,
                password: password,
                rememberMe: rememberMe,
                createdAt: new Date().toISOString()
            };
            
            localStorage.setItem('iwatch_tv_credentials', JSON.stringify(credentials));
            localStorage.setItem('iwatch_tv_expiry', expiryDate);
            
            console.log('ðŸ’¾ Credentials stored for auto-login');
        }
        
        // Clear stored credentials
        function clearStoredCredentials() {
            localStorage.removeItem('iwatch_tv_credentials');
            localStorage.removeItem('iwatch_tv_expiry');
            console.log('ðŸ—‘ï¸ Stored credentials cleared');
        }

        // Ensure built-in sample content exists for immediate use
        function ensureBuiltInContent() {
            // No demo content - all content comes from admin panel and Plex
            console.log('ðŸ“¦ Content loaded from admin panel and Plex cache');
            // This function is now a no-op - all demo content has been removed
        }

        // Check if customer has access to specific package
        function customerHasPackageAccess(packageId) {
            if (!currentUser || !currentUser.customerId) return false;

            const customers = loadCustomersFromAdmin();
            const customer = customers.find(c => c.id === currentUser.customerId || c.username === currentUser.username);
            
            if (!customer) return false;

            // Check if customer has subscription to this package
            return customer.subscribedPackages.includes(packageId);
        }

        // Enhanced Filter content based on package authentication and customer subscription
        function filterContentBySubscription() {
            adminPackages = loadAllPackagesFromAdmin();
            adminCustomers = loadCustomersFromAdmin();

            // ADMIN ACCESS: Admin has full access to all packages and streams
            if (currentUser && currentUser.role === 'admin') {
                console.log(`ðŸ‘‘ ADMIN ACCESS: ${currentUser.username} has full access to all packages`);
                return adminPackages; // Admin sees all packages
            }

            // Use the new package authentication system
            const accessiblePackages = clientPackageAuth.getAccessiblePackages();
            const availablePackages = accessiblePackages.map(item => item.package);

            // Additional filtering for adult content based on password
            const filteredPackages = availablePackages.filter(pkg => {
                // Adult packages require password unlock
                if (pkg.isAdult || pkg.name.toLowerCase().includes('adult')) {
                    return adultUnlocked;
                }
                return true;
            });

            console.log('ðŸ” Enhanced Package Authentication Filtering:', {
                customer: currentUser?.username,
                totalPackages: adminPackages.length,
                accessiblePackages: accessiblePackages.length,
                availableAfterAdultFilter: filteredPackages.length,
                accessiblePackageNames: accessiblePackages.map(item => item.package.name),
                adultUnlocked: adultUnlocked,
                message: accessiblePackages.length > 0 ? 'âœ… Authentication successful' : 'âŒ No accessible packages'
            });

            return filteredPackages;
        }

        // Enhanced content filtering with authentication integration
        function filterContentWithAuth(content, currentSource) {
            // Use the client authentication system to filter content
            const authenticatedContent = clientPackageAuth.filterContentByAuth(content, currentSource);
            
            // Additional source-specific filtering
            let filteredContent = authenticatedContent;
            
            if (currentSource === 'addon') {
                // For addon section, show ALL packages regardless of content mappings
                // Packages should be visible for subscription purposes
                console.log('ðŸ“¦ Addon filter: showing all packages without mapping requirement');
            }
            
            if (currentSource === 'adult') {
                // Adult content requires both package access and password unlock
                filteredContent = filteredContent.filter(item => {
                    if (item.adult || item.category === 'adult') {
                        return adultUnlocked && clientPackageAuth.canAccessAdult();
                    }
                    return true;
                });
            }

            console.log(`ðŸ” Content filtering for ${currentSource}:`, {
                originalCount: content.length,
                authenticatedCount: authenticatedContent.length,
                finalCount: filteredContent.length
            });

            return filteredContent;
        }

        // Load adult packages from admin panel
        function loadAdultPackagesFromAdmin() {
            try {
                const adminPackages = localStorage.getItem('adminPackages');
                if (adminPackages) {
                    const packages = JSON.parse(adminPackages);
                    // Filter packages that are marked as adult or contain adult indicators
                    return packages.filter(pkg => 
                        pkg.isAdult === true || 
                        pkg.name.toLowerCase().includes('adult') || 
                        pkg.name.toLowerCase().includes('xxx') ||
                        (pkg.type === 'adult')
                    ).map(pkg => ({
                        id: pkg.id || 'ADULT_' + Date.now(),
                        name: pkg.name,
                        description: pkg.features || `Adult content package - $${pkg.adultPackagePrice || pkg.price}/${pkg.duration}`,
                        category: 'adult',
                        adult: true,
                        type: 'package',
                        packageId: pkg.id,
                        price: pkg.adultPackagePrice || pkg.price,
                        duration: pkg.duration,
                        streamingMode: 'on-demand'
                    }));
                }
            } catch (e) {
                console.error('Error loading adult packages from admin:', e);
            }
            return [];
        }

        // Get user's assigned package with media libraries and streaming mode
        function getUserAssignedPackage() {
            if (!currentUser || !currentUser.plan) return null;
            
            const allPackages = loadAllPackagesFromAdmin();
            const userPlan = (currentUser.plan || '').toLowerCase();
            
            // Find package based on user plan
            const userPackage = allPackages.find(pkg => {
                if (!pkg || !pkg.name) return false;
                const pkgName = pkg.name.toLowerCase();
                // Match by package name or plan type
                return pkgName.includes(userPlan) ||
                       userPlan.includes(pkgName) ||
                       pkg.type === 'basic' ||
                       (userPlan.includes('basic') && pkg.type === 'basic') ||
                       (userPlan.includes('premium') && pkg.type === 'additional');
            });
            
            return userPackage || null;
        }

        // Get streaming mode for content
        function getContentStreamingMode(content) {
            if (!content) return 'on-demand';
            
            // Plex content (has sectionId) should always stream immediately
            if (content.sectionId) {
                return 'always-streaming';
            }
            
            // Determine streaming mode based on content type and source
            if (content.streamingMode && content.streamingMode !== 'on-demand') {
                return content.streamingMode; // Use explicitly set mode (except on-demand for movies)
            }
            
            // Plex movies are always-streaming
            if (content.type === 'movies' || content.type === 'mp4') {
                return 'always-streaming';
            }
            
            // Auto-detect based on content characteristics (with safety checks)
            const contentName = (content.name || '').toLowerCase();
            const contentDescription = (content.description || '').toLowerCase();
            const category = (content.category || '').toLowerCase();
            
            // Always-streaming content: News, Sports, Movies, Live TV
            const alwaysStreamingKeywords = ['news', 'sport', 'movie', 'cinema', 'film', 'live'];
            const isAlwaysStreaming = alwaysStreamingKeywords.some(keyword => 
                contentName.includes(keyword) || 
                contentDescription.includes(keyword) || 
                category.includes(keyword)
            );
            
            if (isAlwaysStreaming) {
                return 'always-streaming';
            }
            
            // Check source-based streaming mode
            const sourceStreamingModes = {
                'live': 'always-streaming',
                'movies': 'always-streaming',
                'vod': 'on-demand',
                'basic': 'on-demand',
                'addon': 'on-demand',
                'adult': 'on-demand',
                'internet': 'on-demand'
            };
            
            return sourceStreamingModes[currentSource] || 'on-demand';
        }

        // Check if content should preload (for always-streaming)
        function shouldPreloadContent(content) {
            const streamingMode = getContentStreamingMode(content);
            return streamingMode === 'always-streaming';
        }

        // Filter content based on user's package and assigned media libraries
        function filterContentByPackage() {
            const userPackage = getUserAssignedPackage();
            
            if (!userPackage || !userPackage.libraries || userPackage.libraries.length === 0) {
                // If no package or no libraries assigned, show limited content
                console.log('No package libraries assigned, showing basic content only');
                return;
            }

            console.log('ðŸ“¦ User package:', userPackage.name);
            console.log('ðŸ“š Assigned libraries:', userPackage.libraries);
            
            // Update content based on assigned libraries
            updateContentByLibraries(userPackage.libraries);
        }

        // Media API Manager for Client Interface
        class MediaAPI {
            constructor() {
                this.servers = [];
                this.connectedServers = new Map();
                this.loadServerConfigs();
            }
            
            loadServerConfigs() {
                const configs = localStorage.getItem('mediaServerConfigs');
                if (configs) {
                    this.servers = JSON.parse(configs);
                    console.log('ðŸ“¡ Loaded media server configs:', this.servers.length);
                }
            }
            
            async testConnection(server) {
                try {
                    const response = await fetch(`${server.url}/identity?auth_token=${server.token}`);
                    if (response.ok) {
                        const data = await response.json();
                        this.connectedServers.set(server.id, {
                            ...server,
                            deviceName: data.MediaContainer.deviceName,
                            platform: data.MediaContainer.platform,
                            version: data.MediaContainer.version
                        });
                        return { success: true, data };
                    }
                } catch (error) {
                    console.warn('Media connection failed for server:', server.name, error);
                    return { success: false, error: error.message };
                }
            }
            
            async getContentFromLibrary(serverId, libraryId, limit = 50) {
                const server = this.connectedServers.get(serverId);
                if (!server) return [];
                
                try {
                    const response = await fetch(`${server.url}/library/sections/${libraryId}/all?auth_token=${server.token}&limit=${limit}`);
                    if (response.ok) {
                        const data = await response.json();
                        // Check if this is an adult library
                        const isAdultLibrary = libraryId.toLowerCase().includes('adult');
                        return data.MediaContainer.Metadata?.map(item => ({
                            id: `media_${serverId}_${libraryId}_${item.ratingKey}`,
                            name: item.title,
                            description: item.summary || 'No description available',
                            category: isAdultLibrary ? 'adult' : this.getCategoryFromType(item.type),
                            isAdult: isAdultLibrary,
                            adult: isAdultLibrary,
                            type: 'mp4',
                            thumb: `${server.url}${item.thumb}?auth_token=${server.token}`,
                            art: `${server.url}${item.art}?auth_token=${server.token}`,
                            url: `${server.url}/library/metadata/${item.ratingKey}/children?auth_token=${server.token}`,
                            streamingMode: this.getStreamingMode(item.type),
                            year: item.year,
                            duration: item.duration,
                            viewCount: item.viewCount || 0,
                            mediaData: {
                                ratingKey: item.ratingKey,
                                libraryId: libraryId,
                                serverId: serverId,
                                serverName: server.name
                            }
                        })) || [];
                    }
                } catch (error) {
                    console.error('Failed to fetch media content:', error);
                    return [];
                }
            }
            
            getCategoryFromType(type) {
                switch (type) {
                    case 'movie': return 'movie';
                    case 'show': return 'series';
                    case 'episode': return 'episode';
                    default: return 'content';
                }
            }
            
            getStreamingMode(type) {
                // Movies and episodes are always-streaming, shows are on-demand
                return type === 'movie' || type === 'episode' ? 'always-streaming' : 'on-demand';
            }
            
            async getContentFromAssignedLibraries(libraryIds) {
                console.log('ðŸ”„ Fetching content from assigned media libraries:', libraryIds);
                
                if (!libraryIds || libraryIds.length === 0) {
                    console.log('âš ï¸ No libraries assigned, using default content');
                    return this.getDefaultContent();
                }
                
                let allContent = [];
                
                // Process each library assignment
                for (const libraryAssignment of libraryIds) {
                    const [serverId, libraryId] = libraryAssignment.split('_');
                    
                    // Test connection first
                    const server = this.servers.find(s => s.id == serverId);
                    if (server) {
                        const connectionResult = await this.testConnection(server);
                        if (connectionResult.success) {
                            const content = await this.getContentFromLibrary(serverId, libraryId, 50);
                            allContent = allContent.concat(content);
                            console.log(`âœ… Fetched ${content.length} items from ${server.name}`);
                        } else {
                            console.warn(`âŒ Failed to connect to server: ${server.name}`);
                        }
                    }
                }
                
                if (allContent.length === 0) {
                    console.log('âš ï¸ No content retrieved, using default content');
                    return this.getDefaultContent();
                }
                
                console.log(`ðŸ“º Total media content loaded: ${allContent.length} items`);
                return this.organizeContentByType(allContent);
            }
            
            organizeContentByType(content) {
                const organized = {
                    movies: [],
                    series: [],
                    vod: [],
                    live: [],
                    adult: []
                };
                
                content.forEach(item => {
                    // Check for adult content first
                    if (item.isAdult || item.adult || item.category === 'adult') {
                        organized.adult.push(item);
                        return;
                    }
                    
                    switch (item.category) {
                        case 'movie':
                            organized.movies.push(item);
                            break;
                        case 'series':
                        case 'episode':
                            organized.series.push(item);
                            break;
                        default:
                            organized.vod.push(item);
                            break;
                    }
                });
                
                console.log(`ðŸ“Š Content organized: Movies=${organized.movies.length}, Series=${organized.series.length}, VOD=${organized.vod.length}, Adult=${organized.adult.length}`);
                return organized;
            }
            
            getDefaultContent() {
                // Fallback content when no media libraries are assigned
                return {
                    movies: [],
                    series: [],
                    vod: [],
                    live: [],
                    adult: []
                };
            }
        }
        
        // Initialize Media API
        window.mediaAPI = new MediaAPI();

        // Load content directly from Plex Movies and Adult folders
        async function loadPlexLibraryContent() {
            console.log('ðŸ“º ====== PLEX LIBRARY LOADING STARTED ======');
            
            // Try Firebase cache first (synced from admin panel)
            try {
                const moviesDoc = await fireDb.collection('plexMovies').doc('main').get();
                const adultDoc = await fireDb.collection('plexAdult').doc('main').get();
                const liveDoc = await fireDb.collection('liveChannels').doc('main').get();
                if (moviesDoc.exists && moviesDoc.data().list) {
                    const movies = moviesDoc.data().list;
                    contentData.movies.content = movies;
                    localStorage.setItem('plexMoviesCache', JSON.stringify(movies));
                    console.log(`â˜ï¸ Loaded ${movies.length} movies from Firebase`);
                }
                if (adultDoc.exists && adultDoc.data().list) {
                    const adult = adultDoc.data().list;
                    contentData.adult.content = adult;
                    localStorage.setItem('plexAdultCache', JSON.stringify(adult));
                    console.log(`â˜ï¸ Loaded ${adult.length} adult videos from Firebase`);
                }
                if (liveDoc.exists && liveDoc.data().list) {
                    const live = liveDoc.data().list;
                    // Filter channels by package
                    contentData.live.content = live.filter(ch => !ch.package || ch.package === 'basic');
                    contentData['sports-live'].content = live.filter(ch => ch.package === 'sports');
                    contentData['livetv-addon'].content = live.filter(ch => ch.package === 'livetv-addon');
                    localStorage.setItem('liveChannelsCache', JSON.stringify(live));
                    console.log(`â˜ï¸ Loaded ${live.length} live channels from Firebase (Basic: ${contentData.live.content.length}, Sports: ${contentData['sports-live'].content.length}, Addon: ${contentData['livetv-addon'].content.length})`);
                    // Show/hide tabs based on content
                    updateLiveTabs();
                }
            } catch(e) { console.log('Firebase not available, using localStorage:', e.message); }
            
            // Check for cached content FIRST (from PowerShell script)
            const cachedMovies = localStorage.getItem('plexMoviesCache');
            const cachedAdult = localStorage.getItem('plexAdultCache');
            
            console.log('ðŸ“¦ Checking cached Plex content:', {
                moviesCache: cachedMovies ? 'FOUND' : 'NONE',
                adultCache: cachedAdult ? 'FOUND' : 'NONE'
            });
            
            let moviesLoaded = false;
            let adultLoaded = false;
            
            // Load cached content immediately if available
            if (cachedMovies) {
                try {
                    const movies = JSON.parse(cachedMovies);
                    if (movies && movies.length > 0) {
                        contentData.movies.content = movies;
                        console.log(`ðŸ“¦ Loaded ${movies.length} cached movies`);
                        moviesLoaded = true;
                    }
                } catch(e) { console.error('Error parsing cached movies:', e); }
            }
            
            if (cachedAdult) {
                try {
                    const adult = JSON.parse(cachedAdult);
                    if (adult && adult.length > 0) {
                        contentData.adult.content = adult;
                        console.log(`ðŸ“¦ Loaded ${adult.length} cached adult videos`);
                        adultLoaded = true;
                    }
                } catch(e) { console.error('Error parsing cached adult:', e); }
            }
            
            // Update tab counts immediately
            const moviesTabUpdate = document.querySelector('.source-tab[data-source="movies"]');
            if (moviesTabUpdate) moviesTabUpdate.textContent = `Movies (${contentData.movies.content.length})`;
            
            const adultTabUpdate = document.querySelector('.source-tab[data-source="adult"]');
            if (adultTabUpdate) adultTabUpdate.textContent = `Adult (${contentData.adult.content.length})`;
            
            // Refresh display if cached content loaded
            if (moviesLoaded || adultLoaded) {
                console.log('ðŸ“º ====== PLEX CONTENT LOADED FROM CACHE ======');
                console.log('ðŸ“º Final counts:', { movies: contentData.movies.content.length, adult: contentData.adult.content.length });
                
                // Always refresh display to show the loaded content
                renderContent();
                return;
            }
            
            // If no cache, try live fetch with token
            // Clear any old wrong URLs and set correct default
            if (localStorage.getItem('plexServerUrl') === 'http://127.0.0.1:32400') {
                localStorage.removeItem('plexServerUrl');
            }
            const plexServerUrl = localStorage.getItem('plexServerUrl') || 'http://192.168.1.100:32400';
            const plexToken = localStorage.getItem('plexToken') || localStorage.getItem('plexAutoToken') || 'xcak2s6WSj7hzAinAigm';
            const storedLibraries = localStorage.getItem('plexLibraries');
            
            console.log('ðŸ“º Plex Config:', {
                serverUrl: plexServerUrl,
                tokenExists: !!plexToken,
                tokenPreview: plexToken ? plexToken.substring(0, 10) + '...' : 'NONE',
                storedLibraries: storedLibraries ? 'YES' : 'NO'
            });
            
            if (!plexToken) {
                console.log('âš ï¸ No Plex token and no cached content');
                return;
            }
            
            // First try to use stored libraries from admin panel
            let libraries = [];
            if (storedLibraries) {
                try {
                    libraries = JSON.parse(storedLibraries);
                    console.log('ðŸ“š Using stored libraries from admin:', libraries.map(l => l.title || l.name));
                } catch (e) {
                    console.warn('âš ï¸ Could not parse stored libraries');
                }
            }
            
            // Find Movies and Adult libraries from stored data
            let moviesLib = libraries.find(l => {
                const title = (l.title || l.name || '').toLowerCase();
                return title.includes('movies') || title.includes('movie');
            });
            let adultLib = libraries.find(l => {
                const title = (l.title || l.name || '').toLowerCase();
                return title.includes('adult');
            });
            
            // Fallback to stored section IDs from Firebase
            const moviesSection = localStorage.getItem('plexMoviesSection');
            const adultSection = localStorage.getItem('plexAdultSection');
            if (!moviesLib && moviesSection) {
                moviesLib = { title: 'Movies', key: moviesSection };
            }
            if (!adultLib && adultSection) {
                adultLib = { title: 'Adult', key: adultSection };
            }
            
            console.log('ðŸ“º Library detection:', {
                moviesLib: moviesLib ? `${moviesLib.title || moviesLib.name} (ID: ${moviesLib.key || moviesLib.id})` : 'NOT FOUND',
                adultLib: adultLib ? `${adultLib.title || adultLib.name} (ID: ${adultLib.key || adultLib.id})` : 'NOT FOUND'
            });
            
            let moviesLoadedLive = false;
            let adultLoadedLive = false;
            
            try {
                // Load movies content
                if (moviesLib) {
                    const libraryKey = moviesLib.key || moviesLib.id;
                    console.log(`ðŸŽ¬ Loading movies from library: ${moviesLib.title || moviesLib.name} (ID: ${libraryKey})`);
                    const moviesContent = await fetchPlexLibraryContent(plexServerUrl, plexToken, libraryKey, false);
                    if (moviesContent.length > 0) {
                        contentData.movies.content = moviesContent;
                        console.log(`âœ… Loaded ${moviesContent.length} movies from Plex`);
                        // Cache for future use
                        try { 
                            localStorage.setItem('plexMoviesCache', JSON.stringify(moviesContent));
                            // Also save to Firebase for mobile access
                            fireDb.collection('plexCache').doc('movies').set({content: moviesContent, updated: Date.now()});
                            console.log('â˜ï¸ Synced movies to Firebase');
                        } catch(e) {}
                        moviesLoadedLive = true;
                    } else {
                        console.log('âš ï¸ No movies loaded from direct Plex fetch');
                    }
                }
                
                // Load adult content
                if (adultLib) {
                    const libraryKey = adultLib.key || adultLib.id;
                    console.log(`ðŸ”ž Loading adult content from library: ${adultLib.title || adultLib.name} (ID: ${libraryKey})`);
                    const adultContent = await fetchPlexLibraryContent(plexServerUrl, plexToken, libraryKey, true);
                    if (adultContent.length > 0) {
                        // Replace packages with actual video content
                        contentData.adult.content = adultContent;
                        console.log(`âœ… Loaded ${adultContent.length} adult videos from Plex - REPLACING PACKAGES`);
                        // Cache for future use
                        try { 
                            localStorage.setItem('plexAdultCache', JSON.stringify(adultContent));
                            // Also save to Firebase for mobile access
                            fireDb.collection('plexCache').doc('adult').set({content: adultContent, updated: Date.now()});
                            console.log('â˜ï¸ Synced adult content to Firebase');
                        } catch(e) {}
                        adultLoadedLive = true;
                    } else {
                        console.log('âš ï¸ No adult content loaded from direct Plex fetch');
                    }
                }
                
            } catch (error) {
                console.error('âŒ Error loading Plex content directly:', error);
                console.error('âŒ This is likely a CORS issue - browser blocking requests to local Plex server');
            }
            
            // Update tab counts after live fetch
            const moviesTab = document.querySelector('.source-tab[data-source="movies"]');
            if (moviesTab) moviesTab.textContent = `Movies (${contentData.movies.content.length})`;
            
            // Refresh display
            if (currentSource === 'movies' || currentSource === 'addon') {
                displayContent(currentSource);
            }
            
            console.log('ðŸ“º ====== PLEX LIBRARY LOADING COMPLETE ======');
            console.log('ðŸ“º Final counts:', {
                movies: contentData.movies.content.length,
                adult: contentData.adult.content.length
            });
        }
        
        // Fetch content from a specific Plex library
        async function fetchPlexLibraryContent(serverUrl, token, libraryKey, isAdult = false) {
            const url = `${serverUrl}/library/sections/${libraryKey}/all?X-Plex-Token=${token}`;
            console.log(`ðŸ“¡ Fetching Plex library: ${url.replace(token, 'TOKEN_HIDDEN')}`);
            
            try {
                const response = await fetch(url);
                console.log(`ðŸ“¡ Plex response status: ${response.status}`);
                
                if (!response.ok) {
                    console.error(`âŒ Plex fetch failed with status ${response.status}`);
                    return [];
                }
                
                // Plex returns XML, parse it
                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                const videoElements = xml.querySelectorAll('Video');
                const items = Array.from(videoElements).map(v => ({
                    ratingKey: v.getAttribute('ratingKey'),
                    title: v.getAttribute('title'),
                    summary: v.getAttribute('summary'),
                    thumb: v.getAttribute('thumb'),
                    art: v.getAttribute('art'),
                    year: v.getAttribute('year'),
                    duration: v.getAttribute('duration'),
                    Media: [{ Part: [{ key: v.querySelector('Part')?.getAttribute('key') }] }]
                }));
                console.log(`ðŸ“¡ Plex returned ${items.length} items for library ${libraryKey}`);
                
                return items.map((item, index) => ({
                    id: `plex_${libraryKey}_${item.ratingKey || index}`,
                    name: item.title,
                    description: item.summary || 'No description available',
                    category: isAdult ? 'adult' : 'movie',
                    isAdult: isAdult,
                    adult: isAdult,
                    type: 'mp4',
                    thumb: item.thumb ? `${serverUrl}${item.thumb}?X-Plex-Token=${token}` : '',
                    art: item.art ? `${serverUrl}${item.art}?X-Plex-Token=${token}` : '',
                    url: item.Media?.[0]?.Part?.[0]?.key ? `${serverUrl}${item.Media[0].Part[0].key}?X-Plex-Token=${token}` : '',
                    streamingMode: 'on-demand',
                    year: item.year,
                    duration: item.duration,
                    ratingKey: item.ratingKey
                }));
            } catch (error) {
                console.error(`âŒ Error fetching library ${libraryKey}:`, error);
                if (error.message?.includes('Failed to fetch') || error.name === 'TypeError') {
                    console.error('ðŸš« CORS ERROR: Browser is blocking requests to Plex server.');
                    console.error('ðŸ’¡ Solutions:');
                    console.error('   1. Serve this page from same origin as Plex (e.g., Plex server itself)');
                    console.error('   2. Use a proxy server to route Plex requests');
                    console.error('   3. Configure Plex with CORS headers (advanced)');
                }
                return [];
            }
        }

        // Update content based on assigned media libraries
        async function updateContentByLibraries(libraryIds) {
            console.log('ðŸ”§ updateContentByLibraries called with library IDs:', libraryIds);
            
            // Show loading state
            const loadingIndicator = document.createElement('div');
            loadingIndicator.id = 'contentLoadingIndicator';
            loadingIndicator.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 20px;
                border-radius: 12px;
                z-index: 10000;
                text-align: center;
            `;
            loadingIndicator.innerHTML = `
                <div style="margin-bottom: 15px;">ðŸ“º</div>
                <div>Loading your content...</div>
            `;
            document.body.appendChild(loadingIndicator);
            
            try {
                const mediaContent = await window.mediaAPI.getContentFromAssignedLibraries(libraryIds);
                
                // Clear existing content
                contentData.movies.content = [];
                contentData.vod.content = [];
                contentData.series.content = [];
                
                // Update with media content
                if (mediaContent.movies.length > 0) {
                    contentData.movies.content = mediaContent.movies;
                    console.log(`ðŸŽ¬ Loaded ${mediaContent.movies.length} movies`);
                }
                
                if (mediaContent.series.length > 0) {
                    contentData.series.content = mediaContent.series;
                    console.log(`ðŸ“º Loaded ${mediaContent.series.length} series/episodes`);
                }
                
                if (mediaContent.vod.length > 0) {
                    contentData.vod.content = mediaContent.vod;
                    console.log(`ðŸ“€ Loaded ${mediaContent.vod.length} VOD items`);
                }
                
                // Load adult content from Plex adult library
                if (mediaContent.adult && mediaContent.adult.length > 0) {
                    contentData.adult.content = mediaContent.adult;
                    console.log(`ðŸ”ž Loaded ${mediaContent.adult.length} adult videos from Plex`);
                }
                
                // Update tab labels with real counts
                const moviesTab = document.querySelector('.source-tab[data-source="movies"]');
                const vodTab = document.querySelector('.source-tab[data-source="vod"]');
                if (moviesTab) moviesTab.textContent = `Movies (${contentData.movies.content.length})`;
                if (vodTab) vodTab.textContent = `VOD (${contentData.vod.content.length})`;
                
                console.log('âœ… Content updated from media libraries');
                
                // Refresh display if currently viewing affected sections
                if (['movies', 'vod', 'series', 'adult'].includes(currentSource)) {
                    displayContent(currentSource);
                }
                
                // Show success message
                if (libraryIds && libraryIds.length > 0) {
                    const totalLoaded = mediaContent.movies.length + mediaContent.series.length + mediaContent.vod.length + (mediaContent.adult?.length || 0);
                    showSuccess(`Loaded ${totalLoaded} items from your media libraries`);
                }
                
            } catch (error) {
                console.error('Error loading media content:', error);
                showError('Failed to load media content. Using default content.');
                // Fall back to default content
                const defaultContent = window.mediaAPI.getDefaultContent();
                contentData.movies.content = defaultContent.movies;
                displayContent('movies');
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('contentLoadingIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        }

        // Content Data
        const contentData = {
            live: {
                name: 'Live TV',
                content: [], // Channels loaded from Firebase/admin (basic package)
                streamingMode: 'always-streaming' // Live TV always streams
            },
            'sports-live': {
                name: 'Sports TV',
                content: [], // Sports channels (sports addon)
                streamingMode: 'always-streaming'
            },
            'livetv-addon': {
                name: 'TV Addon',
                content: [], // TV Addon channels
                streamingMode: 'always-streaming'
            },
            movies: {
                name: 'Movies',
                content: [],
                streamingMode: 'always-streaming' // Movies always stream for better UX
            },
            vod: {
                name: 'VOD Library',
                content: [],
                streamingMode: 'on-demand' // VOD streams on-demand
            },
            basic: {
                name: 'Basic Package',
                content: [],
                streamingMode: 'on-demand' // Basic packages on-demand
            },
            addon: {
                name: 'Add-on Packages',
                content: loadPackagesFromAdmin(), // Load from admin panel
                streamingMode: 'mixed' // Mixed - depends on package
            },
            adult: {
                name: 'Adult Content',
                content: loadAdultPackagesFromAdmin(), // Load adult packages
                streamingMode: 'on-demand' // Adult content on-demand
            },
            internet: {
                name: 'Internet Videos',
                content: [],
                streamingMode: 'on-demand' // Internet videos on-demand
            }
        };

        // Helper Functions for Content Display
        function getSourceIcon(source) {
            switch(source) {
                case 'live': return 'ðŸ”´';
                case 'movies': return 'ðŸŽ¬';
                case 'vod': return 'ðŸ“€';
                case 'basic': return 'ðŸ ';
                case 'addon': return 'ðŸ”§';
                case 'internet': return 'ðŸŒ';
                default: return 'ðŸ“º';
            }
        }

        function getBadgeClass(source) {
            switch(source) {
                case 'live': return 'badge-live';
                case 'movies': return 'badge-movies';
                case 'vod': return 'badge-vod';
                case 'basic': return 'badge-basic';
                case 'addon': return 'badge-addon';
                case 'internet': return 'badge-internet';
                default: return 'badge-internet';
            }
        }

        function getBadgeText(source) {
            switch(source) {
                case 'live': return 'LIVE';
                case 'movies': return 'MOVIE';
                case 'vod': return 'VOD';
                case 'basic': return 'BASIC';
                case 'addon': return 'ADDON';
                case 'internet': return 'NET';
                default: return 'NET';
            }
        }

        // Authentication Functions
        function hasAddonAccess(addonName) {
            // Check if user has required addon subscription
            if (!currentUser || !currentUser.permissions) {
                return false;
            }
            
            // Admin and reseller always have access
            if (currentUser.role === 'admin' || currentUser.role === 'reseller') {
                return true;
            }
            
            // Check if user has specific addon subscription
            return currentUser.permissions.includes(addonName) || currentUser.permissions.includes('full_access');
        }

        async function loginUser(username, password) {
            // Direct Firebase login - bypass passwordManager
            try {
                const doc = await firebase.firestore().collection('customers').doc('main').get();
                if (doc.exists) {
                    const data = doc.data();
                    const customers = data.list || [];
                    const user = customers.find(c => c.username === username && c.password === password);
                    
                    if (user) {
                        isLoggedIn = true;
                        currentUser = user;
                        adminCustomers = customers;
                        localStorage.setItem('adminCustomers', JSON.stringify(customers));
                        
                        console.log('âœ… Login successful:', user.username);
                        updateUserInterface();
                        hideLoginModal();
                        showSuccess(`Welcome back, ${user.username}!`);
                        // Refresh content from Firebase on login
                        loadPlexLibraryContent();
                        return true;
                    }
                }
            } catch(e) {
                console.error('Firebase login error:', e);
            }
            
            // Fallback to old method
            const user = passwordManager.authenticateUser(username, password);
            if (user) {
                isLoggedIn = true;
                currentUser = user;
                adminCustomers = loadCustomersFromAdmin();
                updateUserInterface();
                hideLoginModal();
                showSuccess(`Welcome back, ${user.username}!`);
                // Refresh content from Firebase on login
                loadPlexLibraryContent();
                return true;
            }
            
            return false;
        }

        function logoutUser() {
            isLoggedIn = false;
            currentUser = null;
            adultUnlocked = false;
            stopStream();
            updateUserInterface();
            
            // Clear stored credentials when logging out
            clearStoredCredentials();
            
            showLoginModal();
        }
        
        // Check for subscription expiration and clear stored credentials if expired
        function checkSubscriptionExpiration() {
            try {
                const storedExpiry = localStorage.getItem('iwatch_tv_expiry');
                if (storedExpiry) {
                    const expiryDate = new Date(storedExpiry);
                    const currentDate = new Date();
                    
                    if (currentDate >= expiryDate) {
                        console.log('â° Subscription expired, clearing stored credentials');
                        clearStoredCredentials();
                        
                        if (isLoggedIn) {
                            showError('Your subscription has expired. Please contact support.');
                            logoutUser();
                        }
                    }
                }
            } catch (error) {
                console.error('âŒ Error checking subscription expiration:', error);
            }
        }

        function updateUserInterface() {
            const userStatus = document.getElementById('userStatus');
            const userName = document.getElementById('userName');
            const subscriptionExpiry = document.getElementById('subscriptionExpiry');
            const subscriptionPackages = document.getElementById('subscriptionPackages');
            const logoutBtn = document.getElementById('logoutBtn');
            
            // Safety check for DOM elements
            if (!userStatus || !userName || !subscriptionExpiry || !subscriptionPackages) {
                console.warn('User interface elements not found');
                return;
            }
            
            console.log('ðŸ”„ Updating user interface - Logged in:', isLoggedIn, 'Current user:', currentUser);
            
            // Show/hide logout button based on login status
            if (logoutBtn) {
                if (isLoggedIn) {
                    logoutBtn.classList.add('show');
                } else {
                    logoutBtn.classList.remove('show');
                }
            }
            
            if (isLoggedIn && currentUser) {
                // Clear any previous state first
                userName.textContent = '';
                subscriptionExpiry.textContent = '';
                
                // Set logged in state
                userName.textContent = currentUser.username;
                
                // Display subscription packages (plan + addons)
                let allPackages = '';
                if (currentUser.plan) {
                    allPackages += currentUser.plan;
                }
                if (currentUser.addons) {
                    if (allPackages) allPackages += ', ';
                    allPackages += currentUser.addons;
                }
                if (allPackages) {
                    subscriptionPackages.textContent = allPackages;
                    subscriptionPackages.style.display = 'none'; // Keep hidden
                }
                
                // Fix date comparison - handle YYYY-MM-DD format properly with BULLETPROOF validation
                const expiryDateStr = currentUser.expiryDate;
                const today = new Date();
                
                // Debug logging
                console.log('ðŸ” Debug - Expiry Date String:', expiryDateStr);
                console.log('ðŸ” Debug - Today:', today.toISOString().split('T')[0]);
                
                // Create date objects for comparison (normalize to midnight)
                let expiryDate, expiryStart;
                
                // BULLETPROOF date validation
                if (!expiryDateStr || expiryDateStr === 'undefined' || expiryDateStr === 'null' || expiryDateStr === '') {
                    console.warn('âš ï¸ No valid expiry date provided, showing as unknown');
                    subscriptionExpiry.textContent = 'Contact support';
                    return;
                }
                
                try {
                    expiryDate = new Date(expiryDateStr);
                    // Comprehensive validation - check if date is valid
                    if (isNaN(expiryDate.getTime()) || expiryDate.toString() === 'Invalid Date') {
                        console.warn('âš ï¸ Invalid expiry date format:', expiryDateStr);
                        subscriptionExpiry.textContent = 'Invalid date format';
                        return;
                    }
                    expiryStart = new Date(expiryDate.getFullYear(), expiryDate.getMonth(), expiryDate.getDate());
                } catch (error) {
                    console.error('âŒ Error parsing expiry date:', expiryDateStr, error);
                    subscriptionExpiry.textContent = 'Date error';
                    return;
                }
                
                const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                
                console.log('ðŸ” Debug - Today Start:', todayStart.toISOString().split('T')[0]);
                if (expiryStart) {
                    console.log('ðŸ” Debug - Expiry Start:', expiryStart.toISOString().split('T')[0]);
                }
                
                const daysRemaining = Math.ceil((expiryStart - todayStart) / (1000 * 60 * 60 * 24));
                console.log('ðŸ” Debug - Days Remaining:', daysRemaining);
                
                if (daysRemaining >= 0) {
                    if (daysRemaining === 0) {
                        subscriptionExpiry.textContent = 'Expires today';
                    } else if (daysRemaining === 1) {
                        subscriptionExpiry.textContent = '1 day remaining';
                    } else {
                        subscriptionExpiry.textContent = `${daysRemaining} days remaining`;
                    }
                    subscriptionExpiry.className = 'subscription-expiry';
                } else {
                    subscriptionExpiry.textContent = 'Expired';
                    subscriptionExpiry.className = 'subscription-expiry expired';
                }
                
                // Set click handler for logout
                userStatus.onclick = logoutUser;
                
                console.log('âœ… User interface updated - Username:', currentUser.username);
            } else {
                // Clear any previous state first
                userName.textContent = '';
                subscriptionExpiry.textContent = '';
                subscriptionPackages.textContent = '';
                subscriptionPackages.style.display = 'none';
                
                // Set logged out state
                userName.textContent = 'Guest';
                subscriptionExpiry.textContent = 'Please Login';
                subscriptionExpiry.className = 'subscription-expiry';
                userStatus.onclick = showLoginModal;
                
                console.log('âœ… User interface updated - Guest state');
            }
        }

        // Package Authentication Display Functions
        function getAccessStatusDisplay(item, hasAccess) {
            if (!currentUser || !item) return null;
            
            // If user has access, show appropriate status
            if (hasAccess) {
                return {
                    icon: 'âœ…',
                    text: 'Accessible',
                    class: 'accessible'
                };
            }
            
            // Check if content requires specific package
            if (item.packageRequired) {
                return {
                    icon: 'ðŸ”’',
                    text: 'Package Required',
                    class: 'locked'
                };
            }
            
            // Check if content is in a restricted category
            const restrictedCategories = ['premium', 'exclusive', 'premium-movies', 'premium-series'];
            if (restrictedCategories.includes(item.category)) {
                return {
                    icon: 'ðŸ”’',
                    text: 'Premium Content',
                    class: 'locked'
                };
            }
            
            return null;
        }

        function showUpgradePrompt(contentId) {
            const content = contentData[currentSource].content.find(item => item.id === contentId);
            if (!content) return;
            
            // Get customer's current packages
            const accessiblePackages = clientPackageAuth.getAccessiblePackages();
            const currentPackages = accessiblePackages.map(item => item.package.name);
            
            // Create upgrade modal content
            const upgradeModal = document.createElement('div');
            upgradeModal.className = 'upgrade-modal';
            upgradeModal.innerHTML = `
                <div class="upgrade-modal-content" style="
                    background: linear-gradient(135deg, #1e3c72, #2a5298);
                    color: white;
                    padding: 30px;
                    border-radius: 15px;
                    max-width: 500px;
                    margin: 50px auto;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                    text-align: center;
                    position: relative;
                ">
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        position: absolute;
                        top: 15px;
                        right: 20px;
                        background: none;
                        border: none;
                        color: white;
                        font-size: 24px;
                        cursor: pointer;
                    ">Ã—</button>
                    
                    <div style="font-size: 48px; margin-bottom: 20px;">ðŸ”’</div>
                    <h2 style="margin-bottom: 15px; color: #fff;">Content Locked</h2>
                    <p style="margin-bottom: 20px; line-height: 1.6;">
                        <strong>${content.name}</strong> requires a premium package subscription to access.
                    </p>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin: 20px 0;">
                        <h4 style="margin-bottom: 10px; color: #fff;">Your Current Packages:</h4>
                        <p style="margin: 0; color: #e0e0e0;">
                            ${currentPackages.length > 0 ? currentPackages.join(', ') : 'No active packages'}
                        </p>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin: 20px 0;">
                        <h4 style="margin-bottom: 10px; color: #fff;">To access this content:</h4>
                        <p style="margin: 0; color: #e0e0e0; font-size: 14px;">
                            Contact your administrator to upgrade your package subscription
                        </p>
                    </div>
                    
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        background: linear-gradient(135deg, #4CAF50, #45a049);
                        color: white;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 25px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        margin-top: 15px;
                        transition: all 0.3s ease;
                    ">Got it, thanks!</button>
                </div>
                <div class="upgrade-modal-overlay" onclick="this.parentElement.remove()" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    z-index: 10000;
                "></div>
            `;
            
            document.body.appendChild(upgradeModal);
            
            // Log the upgrade attempt
            console.log('ðŸ”’ Upgrade prompt shown for content:', {
                contentId: contentId,
                contentName: content.name,
                currentPackages: currentPackages,
                user: currentUser?.username
            });
        }

        // Global function for upgrade prompt access
        window.showUpgradePrompt = showUpgradePrompt;

        // Adult Content Management
        function hideAdultIndicator() {
            const indicator = document.getElementById('adultIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        function showAdultIndicator() {
            const indicator = document.getElementById('adultIndicator');
            if (indicator) {
                indicator.style.display = 'flex';
            }
        }

        function showAdultModal() {
            document.getElementById('adultModal').classList.add('show');
            document.getElementById('adultPassword').value = '';
            document.getElementById('adultPassword').focus();
        }

        // Global function for hiding adult modal - defined early for onclick access
        window.hideAdultModal = function() {
            document.getElementById('adultModal').classList.remove('show');
            document.getElementById('adultPassword').value = '';
        }

        // Show Package Details Modal - VERSION 3.0 FIXED
        function showPackageDetails(packageId) {
            console.log('ðŸš€ðŸš€ðŸš€ NEW CODE VERSION 3.0 LOADED ðŸš€ðŸš€ðŸš€');
            console.log('ðŸ“¦ Opening package details for:', packageId);
            
            // Get packages data
            const packages = JSON.parse(localStorage.getItem('adminPackages') || '[]');
            const packageData = packages.find(p => p.id === packageId);
            
            if (!packageData) {
                console.error('Package not found:', packageId);
                showNotification('âŒ Package not found', 'error');
                return;
            }

            console.log('ðŸ“¦ Package data found:', packageData);

            // Get current user data - use global currentUser object
            const loggedInUser = currentUser?.username || '';
            const customers = JSON.parse(localStorage.getItem('adminCustomers') || '[]');
            // Case-insensitive username matching
            const customer = customers.find(c => c.username?.toLowerCase() === loggedInUser?.toLowerCase());
            
            console.log('ðŸ“¦ Logged in user:', loggedInUser);
            console.log('ðŸ“¦ All customers:', customers.map(c => c.username));
            console.log('ðŸ“¦ Found customer:', customer);
            console.log('ðŸ“¦ Customer plan:', customer?.plan);
            console.log('ðŸ“¦ Customer addons:', customer?.addons);
            
            // Check if user has this package - flexible keyword matching
            const pkgName = (packageData.name || '').trim().toLowerCase();
            const customerPlan = (customer?.plan || '').toLowerCase();
            const customerAddons = (customer?.addons || '').toLowerCase();
            
            // Extract key word from package name (e.g., "movies" from "Movies Package")
            const pkgKeyword = pkgName.replace(/\s*(package|addon|content)\s*/gi, '').trim();
            
            console.log('ðŸ“¦ Package name:', pkgName);
            console.log('ðŸ“¦ Package keyword:', pkgKeyword);
            console.log('ðŸ“¦ Customer plan:', customerPlan);
            console.log('ðŸ“¦ Customer addons:', customerAddons);
            console.log('ðŸ“¦ Plan includes keyword?', customerPlan.includes(pkgKeyword));
            console.log('ðŸ“¦ Addons includes keyword?', customerAddons.includes(pkgKeyword));
            
            // Check if keyword is found in plan or addons
            const hasPackage = customerPlan.includes(pkgKeyword) || customerAddons.includes(pkgKeyword);
            const isActive = hasPackage && (!customer?.expiryDate || new Date(customer.expiryDate) > new Date());
            
            console.log('ðŸ“¦ Has package:', hasPackage, '| Is active:', isActive);

            // Update modal content
            document.getElementById('packageTitle').textContent = packageData.name;
            document.getElementById('packagePrice').textContent = packageData.price ? `$${packageData.price}/month` : 'Contact for pricing';
            document.getElementById('packageDuration').textContent = packageData.duration || 'Monthly';
            
            // Features list - handle both array and string formats
            let features = packageData.features || [];
            if (typeof features === 'string') {
                features = features.split(',').map(f => f.trim()).filter(f => f);
            }
            if (!Array.isArray(features)) {
                features = [];
            }
            const featuresHtml = features.length > 0 
                ? features.map(feature => `<div class="feature-item">âœ… ${feature}</div>`).join('')
                : '<div class="feature-item">ðŸ“‹ Features will be displayed here</div>';
            document.getElementById('packageFeatures').innerHTML = featuresHtml;
            
            // Description
            document.getElementById('packageDescription').textContent = packageData.description || 'Package description will be displayed here';
            
            // Status
            const statusElement = document.getElementById('packageStatus');
            if (isActive) {
                statusElement.innerHTML = '<span class="status-active">âœ… Active Subscription</span>';
                statusElement.className = 'package-status status-active';
            } else if (hasPackage) {
                statusElement.innerHTML = '<span class="status-expired">âš ï¸ Subscription Expired</span>';
                statusElement.className = 'package-status status-expired';
            } else {
                statusElement.innerHTML = '<span class="status-inactive">ðŸ“¦ Not Subscribed</span>';
                statusElement.className = 'package-status status-inactive';
            }
            
            // Show modal
            document.getElementById('packageModal').classList.add('show');
            console.log('ðŸ“¦ Package modal opened successfully');
        }

        // Hide Package Details Modal
        function hidePackageDetails() {
            document.getElementById('packageModal').classList.remove('show');
            console.log('ðŸ“¦ Package modal closed');
        }

        // Subscribe to Package (placeholder function)
        function subscribeToPackage() {
            showNotification('ðŸ’³ Subscription feature coming soon! Contact your administrator.', 'info');
            hidePackageDetails();
        }

        // Global function for adult password verification - defined early for onclick access
        window.verifyAdultPassword = function() {
            const password = document.getElementById('adultPassword').value;
            
            // Get customer's adult password (if logged in) or use default
            let correctPassword = '8899'; // Default password
            const customPassword = localStorage.getItem('customAdultPassword');
            if (customPassword) {
                correctPassword = customPassword;
            } else if (currentUser && currentUser.adultPassword) {
                correctPassword = currentUser.adultPassword;
            }
            
            // Also check master password for admin access
            const masterPassword = passwordManager.passwords.masterAdult;
            
            if (password === correctPassword || password === masterPassword) {
                adultUnlocked = true;
                showAdultIndicator();
                showAdultTab(); // Show adult tab when password is correct
                updateAdultIndicator();
                hideAdultModal();
                showSuccess('Adult content unlocked');
                renderContent();
            } else {
                showError('Invalid password. Please try again.');
            }
        }
        
        function showChangeAdultPassword() {
            document.getElementById('adultModal').classList.remove('show');
            document.getElementById('changeAdultPasswordModal').classList.add('show');
        }
        
        function hideChangeAdultPassword() {
            document.getElementById('changeAdultPasswordModal').classList.remove('show');
            document.getElementById('currentAdultPass').value = '';
            document.getElementById('newAdultPass').value = '';
            document.getElementById('confirmAdultPass').value = '';
        }
        
        function changeAdultPassword() {
            const current = document.getElementById('currentAdultPass').value;
            const newPass = document.getElementById('newAdultPass').value;
            const confirm = document.getElementById('confirmAdultPass').value;
            
            // Get current password
            let correctPassword = '8899';
            if (currentUser && currentUser.adultPassword) {
                correctPassword = currentUser.adultPassword;
            }
            const masterPassword = passwordManager.passwords.masterAdult;
            
            // Verify current password
            if (current !== correctPassword && current !== masterPassword) {
                showError('Current password is incorrect');
                return;
            }
            
            // Validate new password
            if (newPass.length < 4) {
                showError('Password must be at least 4 digits');
                return;
            }
            
            if (newPass !== confirm) {
                showError('New passwords do not match');
                return;
            }
            
            // Save new password
            if (currentUser) {
                currentUser.adultPassword = newPass;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
            localStorage.setItem('customAdultPassword', newPass);
            
            hideChangeAdultPassword();
            showSuccess('Adult password changed successfully');
        }

        function updateAdultIndicator() {
            const indicator = document.getElementById('adultIndicator');
            if (!indicator) return;
            
            const icon = indicator.querySelector('.adult-icon');
            const status = indicator.querySelector('.adult-status');
            
            if (adultUnlocked) {
                indicator.classList.remove('locked');
                indicator.classList.add('unlocked');
                icon.textContent = 'ðŸ”“';
                status.textContent = 'Click to Exit';
            } else {
                indicator.classList.remove('unlocked');
                indicator.classList.add('locked');
                icon.textContent = 'ðŸ”’';
                status.textContent = 'Locked';
            }
        }

        // Global function for exiting adult content - defined early for onclick access
        window.exitAdultContent = function() {
            adultUnlocked = false;
            hideAdultIndicator();
            hideAdultTab(); // Hide adult tab when exiting adult content
            updateAdultIndicator();
            renderContent();
            showSuccess('Adult content locked');
        }

        // Adult Tab Management
        function showAdultTab() {
            const adultTab = document.getElementById('adultTab');
            if (adultTab) {
                adultTab.style.display = 'block';
            }
        }

        function hideAdultTab() {
            const adultTab = document.getElementById('adultTab');
            if (adultTab) {
                adultTab.style.display = 'none';
                // If currently viewing adult content, switch to basic tab
                if (currentSource === 'adult') {
                    switchSource('basic');
                }
            }
        }

        // Content Management
        // Global function for source switching - defined early for onclick access
        window.switchSource = function(source) {
            if (currentSource === source) return;
            
            currentSource = source;
            currentCategory = 'all';
            
            // Update tab active state
            document.querySelectorAll('.source-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-source="${source}"]`).classList.add('active');
            
            renderContent();
        }

        // Display content for specific source (alias for renderContent)
        function displayContent(source) {
            switchSource(source);
        }

        function renderCategories() {
            // Safety check - ensure content exists
            const sourceContent = contentData[currentSource]?.content || [];
            
            // Extract unique categories with safety handling
            const categorySet = new Set(['all']);
            sourceContent.forEach(item => {
                if (!item) return;
                const isAdultContent = item.adult || item.category === 'adult';
                const canViewAdult = adultUnlocked || !isAdultContent;
                if (canViewAdult) {
                    // Use 'general' for Plex content without categories
                    const cat = item.category || (item.type === 'movies' ? 'movies' : 'general');
                    if (cat && typeof cat === 'string') {
                        categorySet.add(cat);
                    }
                }
            });
            
            const categories = Array.from(categorySet);
            
            const categoryGrid = document.getElementById('categoryGrid');
            if (!categoryGrid) return;
            
            categoryGrid.innerHTML = categories.map(category => {
                if (!category || typeof category !== 'string') return '';
                const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
                const isAdult = category === 'adult';
                const className = `category-btn ${isAdult ? 'adult' : ''} ${currentCategory === category ? 'active' : ''}`;
                
                return `<button class="${className}" onclick="selectCategory('${category}')">${categoryName}</button>`;
            }).join('');
        }

        // Global function for category selection - defined early for onclick access
        window.selectCategory = function(category) {
            currentCategory = category;
            renderContent();
        }
        
        // Show/hide Live TV tabs based on content and user access
        function updateLiveTabs() {
            const sportsTab = document.getElementById('sportsLiveTab');
            const tvAddonTab = document.getElementById('liveTvAddonTab');
            
            // Check if user has access to these packages
            const hasSportsAccess = currentUser && (currentUser.role === 'admin' || 
                (currentUser.addons && currentUser.addons.includes('Sports')) ||
                (currentUser.packages && currentUser.packages.includes('sports')));
            const hasTvAddonAccess = currentUser && (currentUser.role === 'admin' || 
                (currentUser.addons && currentUser.addons.includes('TV Addon')) ||
                (currentUser.packages && currentUser.packages.includes('livetv-addon')));
            
            // Show tabs if user has access AND there's content
            if (sportsTab) {
                sportsTab.style.display = (hasSportsAccess && contentData['sports-live'].content.length > 0) ? 'block' : 'none';
            }
            if (tvAddonTab) {
                tvAddonTab.style.display = (hasTvAddonAccess && contentData['livetv-addon'].content.length > 0) ? 'block' : 'none';
            }
        }

        function renderContent() {
            renderCategories();
            
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            // Apply customer subscription filtering
            const availablePackages = filterContentBySubscription();
            
            let filteredContent = contentData[currentSource].content;
            
            // Apply subscription-based filtering - but keep Plex cached content
            if (['movies', 'vod'].includes(currentSource)) {
                console.log(`ðŸ” Filtering ${currentSource} content - current content count: ${filteredContent.length}`);
                
                // If content is already loaded (e.g., from Plex cache), keep it
                // Only clear if explicitly no access (future enhancement)
                if (filteredContent.length > 0) {
                    console.log(`ðŸ“º Showing ${filteredContent.length} items in ${currentSource} section`);
                } else {
                    console.log(`ðŸ“º ${currentSource}: No content available`);
                }
            }
            
            // Additional subscription filtering for other sections
            if (currentSource === 'addon') {
                // For addon section, show ALL packages so customers can see what's available
                // Don't filter by access - customers should see all packages to subscribe to
                console.log('ðŸ“¦ Addon section: showing all packages for subscription options');
            }
            
            // Filter Live TV channels by customer's packages
            if (currentSource === 'live' && currentUser) {
                const customerPackages = currentUser.packages || [];
                const customerPlan = (currentUser.plan || '').toLowerCase();
                const addonsRaw = currentUser.addons || '';
                const customerAddons = typeof addonsRaw === 'string' ? addonsRaw.toLowerCase().split(',').map(a => a.trim()) : [];
                const allPackages = [...customerPackages.map(p => p.toLowerCase()), customerPlan, ...customerAddons];
                
                const hasBasic = allPackages.some(p => p.includes('basic') || p.includes('tv'));
                const hasSports = allPackages.some(p => p.includes('sport'));
                const isAdmin = currentUser.role === 'admin';
                
                filteredContent = filteredContent.filter(channel => {
                    if (isAdmin) return true; // Admin sees all
                    if (channel.package === 'basic') return hasBasic || hasSports;
                    if (channel.package === 'sports') return hasSports;
                    return true;
                });
                console.log(`ðŸ“º Live TV filtered: ${filteredContent.length} channels (Basic: ${hasBasic}, Sports: ${hasSports}, Plan: ${customerPlan})`);
            }
            
            const availableContent = filteredContent.filter(item => {
                if (!item || !item.name) return false;
                const itemName = (item.name || '').toLowerCase();
                const itemDesc = (item.description || '').toLowerCase();
                const itemCat = item.category || (item.type === 'movies' ? 'movies' : 'general');
                const matchesSearch = itemName.includes(searchTerm) || itemDesc.includes(searchTerm);
                const matchesCategory = currentCategory === 'all' || itemCat === currentCategory;
                const isAdultContent = item.adult || item.category === 'adult';
                const canViewAdult = adultUnlocked || !isAdultContent;
                
                // Check addon access for addon section
                let canViewAddon = true;
                if (currentSource === 'addon' && item.requiresAddon) {
                    canViewAddon = hasAddonAccess(item.requiresAddon);
                }
                
                return matchesSearch && matchesCategory && canViewAdult && canViewAddon;
            });
            
            const contentList = document.getElementById('contentList');
            
            // Clean display - no import buttons needed for plug-and-play experience
            if (availableContent.length === 0) {
                const message = currentSource === 'addon' ? 
                    '<div class="empty-message">ðŸ“¦ No subscription packages available. Login to see available packages.</div>' :
                    '<div class="empty-message">No content available in this section.</div>';
                contentList.innerHTML = message;
                return;
            }
            
            contentList.innerHTML = availableContent.map((item, index) => {
                const typeIcon = getSourceIcon(currentSource);
                const typeBadge = getBadgeClass(currentSource);
                const contentType = getBadgeText(currentSource);
                const isAdult = item.adult || item.category === 'adult';
                const className = `content-item ${currentSource} ${isAdult ? 'adult-content' : ''}`;
                
                // Package Authentication Status
                const hasAccess = clientPackageAuth.canAccessContent(item);
                const isLocked = !hasAccess && item.type !== 'package';
                const accessStatus = getAccessStatusDisplay(item, hasAccess);
                
                // Enhanced content display for addon section - only show pricing to logged-in users
                let priceDisplay = '';
                if (currentSource === 'addon' && item.type === 'package' && currentUser) {
                    priceDisplay = isAdult && item.adultPrice ? 
                        `<div style="font-size: 11px; color: #ff6b6b; font-weight: 600;">ðŸ”ž Adult: $${item.adultPrice}/${item.duration}</div>` :
                        `<div style="font-size: 11px; color: var(--success-color); font-weight: 600;">ðŸ’° $${item.price}/${item.duration}</div>`;
                }
                
                // Lock icon and upgrade prompt for unauthorized content
                const lockIcon = isLocked ? 'ðŸ”’' : '';
                const upgradePrompt = isLocked ? `
                    <div class="upgrade-prompt" style="
                        background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
                        color: white;
                        padding: 8px 12px;
                        margin-top: 8px;
                        border-radius: 8px;
                        font-size: 11px;
                        font-weight: 600;
                        text-align: center;
                        cursor: pointer;
                        border: none;
                        transition: all 0.3s ease;
                        box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
                    " onclick="showUpgradePrompt('${item.id}')">
                        ðŸ”“ Upgrade Package to Access
                    </div>
                ` : '';
                
                const clickAction = isLocked ? 
                    `showUpgradePrompt('${item.id}')` : 
                    (item.type === 'package' ? `showPackageDetails('${item.packageId}')` : `playContent('${item.id}')`);
                
                return `
                    <div class="${className} ${isLocked ? 'locked-content' : ''}" onclick="${clickAction}">
                        <div class="content-type-badge ${typeBadge}">${isAdult ? 'ðŸ”ž ADULT' : contentType}</div>
                        ${isLocked ? '<div class="lock-overlay"><div class="lock-icon">ðŸ”’</div></div>' : ''}
                        <div class="content-header">
                            <div class="content-icon">${isAdult ? 'ðŸ”ž' : (isLocked ? 'ðŸ”’' : typeIcon)}</div>
                            <div class="content-info">
                                <div class="content-name">
                                    ${isAdult ? 'ðŸ”ž ' : ''}${lockIcon}${item.name}
                                    ${!isLocked && accessStatus ? `<span class="access-status-badge ${accessStatus.class}">${accessStatus.icon} ${accessStatus.text}</span>` : ''}
                                </div>
                                <div class="content-description">${item.description || ''}</div>
                                ${priceDisplay}
                                ${upgradePrompt}
                                <div class="content-status">
                                    ${currentSource === 'live' ? '<div class="live-indicator"></div>' : ''}
                                    <span>${(item.category || item.type || 'general').charAt(0).toUpperCase() + (item.category || item.type || 'general').slice(1)}</span>
                                    ${(() => {
                                        const streamingMode = getContentStreamingMode(item);
                                        return streamingMode === 'always-streaming' ? 
                                            '<span class="streaming-indicator always">ðŸ”´ Always On</span>' :
                                            '<span class="streaming-indicator on-demand">â¸ï¸ On-Demand</span>';
                                    })()}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Video Player Functions
        function initializePlayer() {
            player = videojs('videoPlayer', {
                controls: true,
                responsive: true,
                fluid: true,
                playbackRates: [0.5, 1, 1.25, 1.5, 2],
                sources: []
            });

            player.ready(() => {
                console.log('Video.js player ready');
            });
        }

        // Global function for playing content - defined early for onclick access
        window.playContent = function(contentId) {
            alert('DEBUG: playContent called with ID: ' + contentId);
            console.log('DEBUG: playContent called with ID:', contentId);
            
            if (!isLoggedIn) {
                showError('Please login to start watching');
                return;
            }
            
            // Search in current source first, then fallback to movies/adult for Plex content
            let content = contentData[currentSource]?.content?.find(item => String(item.id) === String(contentId));
            
            // Fallback: search in movies section for Plex content
            if (!content && contentData.movies?.content) {
                content = contentData.movies.content.find(item => String(item.id) === String(contentId));
                if (content) console.log('ðŸ“º Found content in movies section:', content.name);
            }
            
            // Fallback: search in adult section for Plex content
            if (!content && contentData.adult?.content) {
                content = contentData.adult.content.find(item => String(item.id) === String(contentId));
                if (content) console.log('ðŸ“º Found content in adult section:', content.name);
            }
            
            if (!content) {
                console.log('âŒ Content not found:', contentId);
                return;
            }
            
            // If content is a package, show package details instead of trying to play
            if (content.type === 'package') {
                console.log('ðŸ“¦ Redirecting package to details modal:', content.name);
                showPackageDetails(content.packageId);
                return;
            }
            
            // Check package authentication access
            if (!clientPackageAuth.canAccessContent(content)) {
                console.log('ðŸ”’ Content access denied - package authentication required:', content.name);
                showUpgradePrompt(contentId);
                return;
            }
            
            // Check adult content access
            if (content.adult || content.category === 'adult') {
                if (!adultUnlocked) {
                    showAdultModal();
                    return;
                }
            }
            
            currentContent = content;
            
            // Hide overlay
            document.getElementById('videoOverlay').classList.remove('show');
            
            // Update now playing
            updateNowPlaying(content);
            
            // Handle different content types with streaming mode optimization
            const streamingMode = getContentStreamingMode(content);
            
            if (streamingMode === 'always-streaming') {
                // Always-streaming content: start immediately without delay
                console.log('ðŸ”´ Playing always-streaming content:', content.name);
                if (content.type === 'udp') {
                    // UDP multicast - launch VLC
                    handleUDPStream(content);
                } else if (content.type === 'hls' || content.type === 'movies' || content.url?.includes('.m3u8')) {
                    handleHLSContent(content);
                } else if (content.type === 'mp4') {
                    handleMP4Content(content);
                } else {
                    showError('Unsupported content type: ' + content.type);
                }
            } else {
                // On-demand content: show loading indicator for 2 seconds, then stream
                console.log('â¸ï¸ Loading on-demand content:', content.name);
                showLoadingIndicator(content.name, streamingMode);
                
                setTimeout(() => {
                    if (content.type === 'hls' || content.type === 'movies' || content.url?.includes('.m3u8')) {
                        handleHLSContent(content);
                    } else if (content.type === 'mp4') {
                        handleMP4Content(content);
                    } else {
                        showError('Unsupported content type: ' + content.type);
                    }
                }, 2000); // 2-second delay as specified
            }
        }

        // Handle Plex content - fetch direct MP4 URL
        async function handlePlexContent(content) {
            // ALWAYS use correct server URL - never use 127.0.0.1
            const CORRECT_SERVER = 'http://192.168.1.100:32400';
            const token = content.plexToken || localStorage.getItem('plexToken') || 'xcak2s6WSj7hzAinAigm';
            const serverUrl = CORRECT_SERVER; // Force correct server
            
            console.log('ðŸ“º Playing Plex content:', content.name);
            console.log('ðŸ“º Server:', serverUrl, 'Token:', token.substring(0, 8) + '...');
            
            try {
                // Method 1: Try the stored HLS transcode URL directly (no fetch needed)
                if (content.url && content.url.includes('transcode')) {
                    // Fix any wrong 127.0.0.1 URLs in cached content
                    let fixedUrl = content.url.replace('http://127.0.0.1:32400', serverUrl);
                    console.log('âœ… Using stored transcode URL (fixed)');
                    handleHLSStream(fixedUrl);
                    return;
                }
                
                // Method 2: Construct direct playback URL (no fetch needed)
                // Plex supports direct file access via this endpoint
                const directStreamUrl = `${serverUrl}/video/:/transcode/universal/start.m3u8?path=%2Flibrary%2Fmetadata%2F${content.id}&mediaIndex=0&partIndex=0&protocol=hls&fastSeek=1&directPlay=0&directStream=1&X-Plex-Token=${token}`;
                
                console.log('âœ… Playing via transcode URL:', directStreamUrl);
                handleHLSStream(directStreamUrl);
                
            } catch (error) {
                console.error('Plex playback error:', error);
                showError('Failed to load content: ' + error.message);
            }
        }
        
        // Handle UDP stream - try direct play in browser
        function handleUDPStream(content) {
            const udpUrl = `${content.url}?program=${content.program}`;
            console.log('ðŸ“º Playing UDP stream directly:', content.name, udpUrl);
            
            // Try to play directly in video player
            const video = player.el().querySelector('video');
            video.src = udpUrl;
            video.load();
            video.play().catch(e => {
                console.log('UDP direct play failed, this is expected in browsers:', e);
                showNotification(`ðŸ“º ${content.name} - Playing...`, 'info');
            });
            
            updateNowPlaying(content);
        }

        // Play HLS stream
        function handleHLSStream(url) {
            // Detect TV devices and mobile - use native HLS playback
            const isLGTV = navigator.userAgent.includes('Web0S') || navigator.userAgent.includes('webOS') || navigator.userAgent.includes('LG');
            const isSamsungTV = navigator.userAgent.includes('Tizen') || navigator.userAgent.includes('Samsung');
            const isAndroidTV = navigator.userAgent.includes('Android') && (navigator.userAgent.includes('TV') || navigator.userAgent.includes('GoogleTV') || navigator.userAgent.includes('Chromecast') || navigator.userAgent.includes('AFT'));
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Force native HLS for all non-desktop devices
            const useNative = isLGTV || isSamsungTV || isAndroidTV || isSafari || isMobile;
            console.log('ðŸ“º Device detection:', {isLGTV, isSamsungTV, isAndroidTV, isSafari, isMobile, useNative, ua: navigator.userAgent});
            
            if (useNative) {
                console.log('ðŸ“º handleHLSStream: Using native HLS for TV/Mobile, URL:', url);
                const video = player.el().querySelector('video');
                if (hls) { hls.destroy(); hls = null; }
                video.src = url;
                video.load();
                video.play().catch(e => {
                    console.log('Play error:', e);
                    alert('Play error: ' + e.message + '\nURL: ' + url);
                });
                return;
            }
            
            if (Hls.isSupported()) {
                if (hls) hls.destroy();
                hls = new Hls();
                hls.loadSource(url);
                hls.attachMedia(player.el().querySelector('video'));
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    player.play().catch(e => console.log('Autoplay blocked'));
                });
                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal) {
                        console.error('HLS Error:', data);
                        showError('Streaming error - try refreshing');
                    }
                });
            } else {
                // Fallback for Safari
                const video = player.el().querySelector('video');
                video.src = url;
                video.load();
                video.play().catch(e => console.log('Autoplay blocked'));
            }
        }
        
        function handleHLSContent(content) {
            // Check if it's Plex content - use direct MP4 instead of HLS transcode
            // sectionId is a Plex-specific property that indicates this is Plex content
            if (content.sectionId) {
                console.log('ðŸŽ¬ Detected Plex content, redirecting to direct playback...');
                handlePlexContent(content);
                return;
            }
            
            // Detect TV devices and mobile - use native HLS playback
            const isLGTV = navigator.userAgent.includes('Web0S') || navigator.userAgent.includes('webOS') || navigator.userAgent.includes('LG');
            const isSamsungTV = navigator.userAgent.includes('Tizen') || navigator.userAgent.includes('Samsung');
            const isAndroidTV = navigator.userAgent.includes('Android') && (navigator.userAgent.includes('TV') || navigator.userAgent.includes('GoogleTV') || navigator.userAgent.includes('Chromecast') || navigator.userAgent.includes('AFT'));
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isLGTV || isSamsungTV || isAndroidTV || isSafari || isMobile) {
                console.log('ðŸ“º Using native HLS playback for TV/Mobile device');
                const video = player.el().querySelector('video');
                if (hls) {
                    hls.destroy();
                    hls = null;
                }
                video.src = content.url;
                video.load();
                video.play().catch(e => console.log('Autoplay blocked - tap to play'));
                return;
            }
            
            if (Hls.isSupported()) {
                if (hls) {
                    hls.destroy();
                }
                
                hls = new Hls();
                hls.loadSource(content.url);
                hls.attachMedia(player.el().querySelector('video'));
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    player.play().catch(e => {
                        showError('Failed to start playback. Please try again.');
                    });
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.log('ðŸ”„ Network error - attempting recovery...');
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('ðŸ”„ Media error - attempting recovery...');
                                hls.recoverMediaError();
                                break;
                            default:
                                console.log('ðŸ”„ Fatal error - reloading stream...');
                                hls.destroy();
                                setTimeout(() => {
                                    playHlsContent(content);
                                }, 2000);
                                break;
                        }
                    }
                });
            } else if (player.tech().isSupported()) {
                player.src({
                    src: content.url,
                    type: 'application/x-mpegURL'
                });
                
                player.ready(() => {
                    player.play().catch(e => {
                        showError('Failed to start playback. Please try again.');
                    });
                });
            } else {
                showError('HLS is not supported in this browser');
            }
        }

        // Show loading indicator for on-demand content
        function showLoadingIndicator(contentName, streamingMode) {
            const overlay = document.getElementById('videoOverlay');
            const title = overlay.querySelector('.overlay-title');
            const description = overlay.querySelector('.overlay-description');
            
            title.textContent = `Loading ${contentName}`;
            description.textContent = streamingMode === 'on-demand' ? 
                'On-demand streaming - please wait 2 seconds' : 
                'Starting stream...';
            
            overlay.classList.add('show');
        }

        // Preload always-streaming content
        function preloadAlwaysStreamingContent() {
            console.log('ðŸ”„ Preloading always-streaming content...');
            
            // Preload content from always-streaming sources
            const alwaysStreamingSources = ['live', 'movies'];
            
            alwaysStreamingSources.forEach(source => {
                const sourceData = contentData[source];
                if (sourceData && sourceData.content.length > 0) {
                    // Find first content item from this source
                    const contentToPreload = sourceData.content[0];
                    if (contentToPreload && shouldPreloadContent(contentToPreload)) {
                        console.log(`ðŸ“º Preloading ${contentToPreload.name} from ${source}`);
                        
                        // Create a hidden video element for preloading
                        const preloadVideo = document.createElement('video');
                        preloadVideo.preload = 'auto';
                        preloadVideo.style.display = 'none';
                        preloadVideo.muted = true;
                        
                        if (contentToPreload.type === 'hls' && Hls.isSupported()) {
                            const preloadHls = new Hls();
                            preloadHls.loadSource(contentToPreload.url);
                            preloadHls.attachMedia(preloadVideo);
                        } else if (contentToPreload.type === 'mp4') {
                            preloadVideo.src = contentToPreload.url;
                        }
                        
                        document.body.appendChild(preloadVideo);
                        
                        // Remove preloaded video after 10 seconds to prevent memory issues
                        setTimeout(() => {
                            if (preloadVideo.parentNode) {
                                preloadVideo.parentNode.removeChild(preloadVideo);
                            }
                        }, 10000);
                    }
                }
            });
        }

        // Initialize preloading after login
        function initializeContentPreloading() {
            if (isLoggedIn && currentUser) {
                setTimeout(preloadAlwaysStreamingContent, 2000); // Wait 2 seconds after login
            }
        }

        // Handle MP4 content playback
        function handleMP4Content(content) {
            player.src({
                src: content.url,
                type: 'video/mp4'
            });
            
            player.ready(() => {
                player.play().catch(e => {
                    showError('Failed to start playback. Please try again.');
                });
            });
        }

        function updateNowPlaying(content) {
            const container = document.getElementById('nowPlayingContent');
            const icon = getSourceIcon(currentSource);
            
            container.innerHTML = `
                <div class="content-avatar">${icon}</div>
                <div class="content-details">
                    <div class="content-current">${content.name || 'Unknown'}</div>
                    <div class="content-meta">
                        ${content.description || ''}<br>
                        <span style="color: var(--success-color);">
                            ${content.type === 'hls' ? 'ðŸ”´ Live' : 
                              currentSource === 'movies' ? 'ðŸŽ¬ Movies' :
                              currentSource === 'vod' ? 'ðŸ“€ VOD' :
                              currentSource === 'basic' ? 'ðŸ  Basic' :
                              currentSource === 'addon' ? 'ðŸ”§ Addon' :
                              currentSource === 'internet' ? 'ðŸŒ Videos' : 
                              'ðŸ“º Live TV'} â€¢ ${(content.type || 'video').toUpperCase()} â€¢ ${
                                (() => {
                                    const streamingMode = getContentStreamingMode(content);
                                    return streamingMode === 'always-streaming' ? 
                                        '<span style="color: #ff4444;">ðŸ”´ Always-Streaming</span>' :
                                        '<span style="color: #666;">â¸ï¸ On-Demand</span>';
                                })()
                              }
                        </span>
                    </div>
                </div>
            `;
        }

        // Global function for starting playback - defined early for onclick access
        window.startPlaying = function() {
            if (!isLoggedIn) {
                showError('Please login to start watching');
                return;
            }
            
            // Find first playable VIDEO (not package) - prioritize movies, then live, then vod
            let content = null;
            const sourcePriority = ['movies', 'live', 'vod', 'adult', 'internet'];
            
            for (const source of sourcePriority) {
                const sourceContent = contentData[source]?.content || [];
                // Find first non-package content
                content = sourceContent.find(item => item.type !== 'package' && item.url);
                if (content) {
                    console.log(`â–¶ï¸ Found playable content in ${source}:`, content.name);
                    break;
                }
            }
            
            if (content) {
                playContent(content.id);
            } else {
                showError('No videos available. Please contact your provider.');
            }
        }

        // Global function for video play/pause - defined early for onclick access
        window.togglePlay = function() {
            if (!player || !currentContent) return;
            
            if (player.paused()) {
                player.play();
            } else {
                player.pause();
            }
        }

        // Global function for fullscreen toggle - defined early for onclick access
        window.toggleFullscreen = function() {
            if (!player) return;
            
            if (player.isFullscreen()) {
                player.exitFullscreen();
            } else {
                player.requestFullscreen();
            }
        }

        // Global function for mute toggle - defined early for onclick access
        window.toggleMute = function() {
            if (!player) return;
            
            player.muted(!player.muted());
        }

        // Global function for stopping stream - defined early for onclick access
        window.stopStream = function() {
            if (!player) return;
            
            player.pause();
            player.src('');
            
            if (hls) {
                hls.destroy();
                hls = null;
            }
            
            // Show overlay
            document.getElementById('videoOverlay').classList.add('show');
            
            // Reset now playing
            const container = document.getElementById('nowPlayingContent');
            container.innerHTML = `
                <div class="content-avatar">ðŸ“º</div>
                <div class="content-details">
                    <div class="content-current">No content selected</div>
                    <div class="content-meta">Login and select content to start watching</div>
                </div>
            `;
            
            // Remove active content
            document.querySelectorAll('.content-item').forEach(item => {
                item.classList.remove('active');
            });
            
            currentContent = null;
        }

        // Modal Management
        // Global function for showing login modal - defined early for onclick access
        window.showLoginModal = function() {
            if (!isLoggedIn) {
                document.getElementById('loginModal').classList.add('show');
                document.getElementById('username').focus();
            }
        }

        function hideLoginModal() {
            document.getElementById('loginModal').classList.remove('show');
        }

        // Event Listeners
        function setupEventListeners() {
            // Login form
            if (document.getElementById('loginForm')) {
                document.getElementById('loginForm').addEventListener('submit', async function(e) {
                    e.preventDefault();
                    
                    const username = document.getElementById('username').value.trim();
                    const password = document.getElementById('password').value.trim();
                    const loginBtn = document.getElementById('loginBtn');
                    
                    if (!username || !password) {
                        console.log('Username and password are required');
                        return;
                    }
                    
                    // Immediate feedback
                    loginBtn.disabled = true;
                    loginBtn.textContent = 'Logging in...';
                    
                    // Ensure button is focusable
                    loginBtn.blur();
                    
                    // Immediate login attempt (removed 1-second delay)
                    const loginSuccess = await loginUser(username, password);
                    console.log('Login attempt result:', loginSuccess);
                    
                    if (loginSuccess) {
                        document.getElementById('username').value = '';
                        document.getElementById('password').value = '';
                    }
                    
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'Login';
                });
                
                // Also add click handler to the login button as backup
                const loginBtn = document.getElementById('loginBtn');
                if (loginBtn) {
                    loginBtn.addEventListener('click', function(e) {
                        // Only handle click if form hasn't already been submitted
                        if (e.detail === 0) return; // Skip if this was triggered by form submit
                        
                        const form = document.getElementById('loginForm');
                        if (form && !loginBtn.disabled) {
                            form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
                        }
                    });
                }
            }

            // Adult password
            document.getElementById('adultPassword').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    verifyAdultPassword();
                }
            });

            // Search
            document.getElementById('searchInput').addEventListener('input', function() {
                renderContent();
            });

            // Volume control
            document.getElementById('volumeSlider').addEventListener('input', function(e) {
                const volume = parseInt(e.target.value);
                if (player) {
                    player.volume(volume / 100);
                }
                document.getElementById('volumeDisplay').textContent = volume + '%';
            });

            // Close modal when clicking outside
            document.getElementById('loginModal').addEventListener('click', function(e) {
                if (e.target.id === 'loginModal') {
                    hideLoginModal();
                }
            });
        }

        // Time Display
        function updateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const dateString = now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            document.getElementById('timeDisplay').textContent = timeString;
            document.getElementById('dateDisplay').textContent = dateString;
        }

        // Utility Functions
        function showError(message) {
            console.log('Error:', message);
            alert(message);
        }

        function showError(message) {
            console.log('Error:', message);
            alert(message);
        }

        function showSuccess(message) {
            console.log('Success:', message);
            alert(message);
        }

        // Auto-sync function - runs on startup
        // HARDCODED SYNC URL - No customer setup required
        const SYNC_URL = 'https://raw.githubusercontent.com/samsat1/app/main/admin_data.json';
        
        window.autoSyncData = async function() {
            const syncUrl = SYNC_URL; // Use hardcoded URL
            
            try {
                console.log('ðŸ“¡ Auto-syncing data from:', syncUrl);
                const response = await fetch(syncUrl + '?t=' + Date.now()); // Cache bust
                if (!response.ok) throw new Error('Fetch failed');
                
                const data = await response.json();
                
                // Import customers
                if (data.customers && Array.isArray(data.customers)) {
                    localStorage.setItem('adminCustomers', JSON.stringify(data.customers));
                }
                // Import packages
                if (data.packages && Array.isArray(data.packages)) {
                    localStorage.setItem('adminPackages', JSON.stringify(data.packages));
                }
                // Import Plex settings
                if (data.plexServerUrl) localStorage.setItem('plexServerUrl', data.plexServerUrl);
                if (data.plexToken) localStorage.setItem('plexToken', data.plexToken);
                if (data.plexMoviesSection) localStorage.setItem('plexMoviesSection', data.plexMoviesSection);
                if (data.plexAdultSection) localStorage.setItem('plexAdultSection', data.plexAdultSection);
                
                localStorage.setItem('lastAutoSync', new Date().toISOString());
                console.log('âœ… Auto-sync completed successfully');
                return true;
            } catch (error) {
                console.log('âš ï¸ Auto-sync failed:', error.message);
                return false;
            }
        };

        // Import Plex cache from JSON file (for local/file:// mode)
        window.importPlexCache = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Import all cache keys
                    if (data.plexMoviesCache) {
                        localStorage.setItem('plexMoviesCache', JSON.stringify(data.plexMoviesCache));
                        localStorage.setItem('plexCachedMovies', JSON.stringify(data.plexMoviesCache));
                    }
                    if (data.plexAdultCache) {
                        localStorage.setItem('plexAdultCache', JSON.stringify(data.plexAdultCache));
                        localStorage.setItem('plexCachedAdult', JSON.stringify(data.plexAdultCache));
                    }
                    if (data.plexConfig) {
                        localStorage.setItem('plexConfig', JSON.stringify(data.plexConfig));
                        localStorage.setItem('plexServerUrl', data.plexConfig.localUrl || data.plexConfig.serverUrl);
                        localStorage.setItem('plexToken', data.plexConfig.token);
                    }
                    
                    const movies = data.plexMoviesCache?.length || 0;
                    const adult = data.plexAdultCache?.length || 0;
                    
                    alert(`âœ… Imported ${movies} movies + ${adult} adult videos!\n\nRefreshing page...`);
                    window.location.reload();
                } catch (err) {
                    alert('âŒ Failed to import: ' + err.message);
                }
            };
            reader.readAsText(file);
        };
        
        // Show import banner if running locally (file://)
        function showLocalModeImportBanner() {
            if (window.location.protocol === 'file:') {
                const banner = document.createElement('div');
                banner.id = 'localImportBanner';
                banner.innerHTML = `
                    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 15px 20px; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px; border-bottom: 2px solid #e94560;">
                        <div style="color: #fff;">
                            <strong>ðŸ’» Local Mode</strong> - Import your content cache from admin panel to enable playback
                        </div>
                        <label style="background: #4CAF50; color: white; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                            ðŸ“¥ Import Cache JSON
                            <input type="file" accept=".json" onchange="importPlexCache(event)" style="display: none;">
                        </label>
                    </div>
                `;
                document.body.insertBefore(banner, document.body.firstChild);
            }
        }

        // Global function for app initialization - defined early for onload access
        window.initApp = async function() {
            
            // Auto-sync on startup (silent, non-blocking)
            autoSyncData();
            
            // DEBUG: Show all localStorage keys
            console.log('ðŸ”‘ ALL localStorage keys:', Object.keys(localStorage));
            console.log('ðŸ”‘ adminPackages raw:', localStorage.getItem('adminPackages'));
            console.log('ðŸ”‘ packages raw:', localStorage.getItem('packages'));
            
            // Initialize player
            initializePlayer();
            
            // Setup event listeners
            setupEventListeners();
            
            // Load customer subscription data (with built-in fallback)
            adminCustomers = loadCustomersFromAdmin();
            console.log('ðŸ‘¥ Loaded customer data:', adminCustomers.length, 'customers');
            
            // Load built-in content if no admin data exists
            ensureBuiltInContent();
            
            // Auto-login check for TV platform
            checkAutoLogin();
            
            // Apply subscription filtering
            const availablePackages = filterContentBySubscription();
            
            // Initialize adult content system
            hideAdultIndicator();
            
            // Check if this is a fresh visit (adult content should be hidden)
            const isFreshVisit = !sessionStorage.getItem('app_visited');
            if (isFreshVisit) {
                adultUnlocked = false;
                hideAdultIndicator();
                sessionStorage.setItem('app_visited', 'true');
            }
            
            // Reset adult visibility on page load if not logged in
            if (!isLoggedIn) {
                adultUnlocked = false;
                hideAdultIndicator();
            }
            
            updateAdultIndicator();
            
            // Initial render
            renderContent();
            
            // Update time display
            updateTime();
            setInterval(updateTime, 1000);
            
            // Update user interface
            updateUserInterface();
            
            // Load packages from admin panel
            refreshAddonPackages();
            
            // Apply package-based content filtering
            filterContentByPackage();
            
            // Load content from Plex Movies and Adult libraries
            loadPlexLibraryContent();
            
            // VOD content will be loaded from admin panel or Plex
            console.log('ðŸ“€ VOD content count:', contentData.vod.content.length);
            
            // Listen for package updates from admin panel
            window.addEventListener('storage', function(e) {
                if (e.key === 'adminPackages') {
                    console.log('ðŸ”„ Packages updated in admin panel, refreshing client...');
                    refreshAddonPackages();
                    // Apply new package-based filtering
                    filterContentByPackage();
                }
                if (e.key === 'adminCustomers') {
                    console.log('ðŸ‘¥ Customer data updated in admin panel, refreshing client...');
                    adminCustomers = loadCustomersFromAdmin();
                    // Re-apply subscription filtering
                    const availablePackages = filterContentBySubscription();
                    renderContent();
                }
            });
            
            // Setup periodic subscription expiration check (every 5 minutes)
            setInterval(checkSubscriptionExpiration, 5 * 60 * 1000);
            
            console.log('iWATCH TV Client initialized successfully');
        }
        
        // Global function for refreshing addon packages - defined early for onclick access
        window.refreshAddonPackages = function() {
            contentData.addon.content = loadPackagesFromAdmin();
            contentData.adult.content = loadAdultPackagesFromAdmin(); // Also refresh adult packages
            console.log(`ðŸ“¦ Loaded ${contentData.addon.content.length} add-on packages from admin panel`);
            console.log(`ðŸ”ž Loaded ${contentData.adult.content.length} adult packages from admin panel`);
            
            // Refresh the display if addon tab is currently active
            if (currentSource === 'addon') {
                displayContent('addon');
            }
            // Also refresh adult tab if it's active
            if (currentSource === 'adult') {
                displayContent('adult');
            }
        }

        // Global function for importing admin data - plug-and-play interface
        window.importAdminData = function() {
            console.log('ðŸ”§ Import button clicked');
            
            // Check if the file input element exists
            const fileInput = document.getElementById('adminDataFileInput');
            if (!fileInput) {
                console.error('âŒ File input element not found');
                showError('ðŸŽ¯ Plug-and-play interface: Login to access your content.');
                return;
            }
            
            console.log('ðŸ“ File input found, clicking to open file picker...');
            
            // Trigger the hidden file input
            fileInput.click();
            
            showSuccess('ðŸ“ Please select a JSON file to import');
        }

        // Export admin data function
        window.exportAdminData = function() {
            console.log('ðŸ”§ Export button clicked');
            
            const adminData = {
                packages: JSON.parse(localStorage.getItem('adminPackages') || '[]'),
                customers: JSON.parse(localStorage.getItem('adminCustomers') || '[]'),
                vodLibraries: JSON.parse(localStorage.getItem('vodLibraries') || '[]'),
                packageLibraries: JSON.parse(localStorage.getItem('packageLibraries') || '[]')
            };
            
            const dataStr = JSON.stringify(adminData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `admin_data_export_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('âœ… Admin data exported successfully');
            showSuccess('âœ… Admin data exported successfully!');
        }

        // Handle admin data file selection and import
        window.handleAdminDataFile = function(event) {
            const file = event.target.files[0];
            if (!file) {
                console.log('ðŸ“ No file selected');
                return;
            }

            console.log('ðŸ“ Loading admin data file:', file.name);

            // Check file extension
            if (!file.name.toLowerCase().endsWith('.json')) {
                showError('âŒ Please select a JSON file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const adminData = JSON.parse(e.target.result);
                    console.log('ðŸ“„ Parsed admin data successfully');
                    
                    if (!adminData || typeof adminData !== 'object') {
                        throw new Error('Invalid JSON format');
                    }
                    
                    // Import packages data
                    if (adminData.packages) {
                        localStorage.setItem('adminPackages', JSON.stringify(adminData.packages));
                        console.log(`ðŸ“¦ Imported ${adminData.packages.length} packages`);
                    }
                    
                    // Import customers data
                    if (adminData.customers) {
                        localStorage.setItem('adminCustomers', JSON.stringify(adminData.customers));
                        console.log(`ðŸ‘¥ Imported ${adminData.customers.length} customers`);
                    }
                    
                    // Import VOD libraries
                    if (adminData.vodLibraries) {
                        localStorage.setItem('vodLibraries', JSON.stringify(adminData.vodLibraries));
                        console.log(`ðŸ“€ Imported ${adminData.vodLibraries.length} VOD libraries`);
                    }
                    
                    // Import package libraries mapping
                    if (adminData.packageLibraries) {
                        localStorage.setItem('packageLibraries', JSON.stringify(adminData.packageLibraries));
                        console.log(`ðŸ”— Imported package libraries mapping`);
                    }
                    
                    console.log('âœ… Admin data imported successfully!');
                    
                    // Show success message
                    showNotification('âœ… Admin data imported successfully! Refreshing interface...', 'success');
                    
                    // Refresh the packages and content
                    setTimeout(() => {
                        refreshAddonPackages();
                        
                        // Force page refresh to reload all content
                        if (typeof window.location.reload === 'function') {
                            window.location.reload();
                        }
                    }, 1500);
                    
                } catch (error) {
                    console.error('âŒ Error importing admin data:', error);
                    
                    // Try to use showNotification, fall back to alert if not available
                    if (typeof showNotification === 'function') {
                        showNotification('âŒ Error importing admin data. Please check the file format and try again.', 'error');
                    } else {
                        alert('âŒ Error importing admin data. Please check the file format and try again.');
                    }
                }
            };
            
            reader.readAsText(file);
            // Clear the input so the same file can be selected again
            event.target.value = '';
        }

        // Show notification function
        window.showNotification = function(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8'};
                color: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: 500;
                font-size: 14px;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            
            // Add CSS animation if not already present
            if (!document.querySelector('#notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Auto remove after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }

        // Adult Content Keyboard Sequence Detection
        document.addEventListener('keydown', function(e) {
            const key = e.key;
            
            // Clear existing timeout
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            // Build the sequence for "1818"
            if (/[0-9]/.test(key)) {
                adultTypingSequence += key;
                
                // Keep only the last 4 digits
                if (adultTypingSequence.length > 4) {
                    adultTypingSequence = adultTypingSequence.slice(-4);
                }
                
                // Reset timeout for sequence detection
                typingTimeout = setTimeout(() => {
                    adultTypingSequence = '';
                }, 2000); // 2 second timeout
                
                // Check if sequence matches "1818"
                if (adultTypingSequence === '1818' && !adultUnlocked) {
                    showAdultModal();
                    adultTypingSequence = '';
                    if (typingTimeout) {
                        clearTimeout(typingTimeout);
                    }
                }
            }
            
            // Handle other keyboard shortcuts only when not in input fields
            if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                switch(e.key) {
                    case 'Escape':
                        if (player && player.isFullscreen()) {
                            player.exitFullscreen();
                        } else if (document.getElementById('loginModal').classList.contains('show')) {
                            hideLoginModal();
                        } else if (document.getElementById('adultModal').classList.contains('show')) {
                            hideAdultModal();
                        } else if (document.getElementById('packageModal').classList.contains('show')) {
                            hidePackageDetails();
                        }
                        break;
                        
                    case 'l':
                    case 'L':
                        e.preventDefault();
                        if (!isLoggedIn) {
                            showLoginModal();
                        } else {
                            logoutUser();
                        }
                        break;
                        
                    case 'a':
                    case 'A':
                        e.preventDefault();
                        showAdultModal();
                        break;
                        
                    case 'x':
                    case 'X':
                        e.preventDefault();
                        if (adultUnlocked) {
                            exitAdultContent();
                        }
                        break;
                }
            }
        });

        // ============================================
        // TV REMOTE CONTROL NAVIGATION SYSTEM
        // Supports: Android TV, Samsung Tizen, LG webOS, Roku, Apple TV, Fire TV
        // ============================================
        
        const tvRemote = {
            focusableElements: [],
            currentFocusIndex: 0,
            scrollAccumulator: 0,
            scrollThreshold: 50,  // Pixels before triggering navigation
            lastScrollTime: 0,
            
            // Initialize focusable elements
            init() {
                this.updateFocusableElements();
                this.setupRemoteListeners();
                this.setupScrollWheel();
                this.setupTouchpad();
                this.addFocusStyles();
                console.log('ðŸ“º TV Remote Control initialized (with scroll wheel support)');
            },
            
            // Setup scroll wheel for LG Magic Remote, Samsung Smart Remote
            // Also allows natural scrolling in scrollable containers
            setupScrollWheel() {
                document.addEventListener('wheel', (e) => {
                    // Check if scrolling inside a scrollable container (content list, modal, etc.)
                    const scrollableSelectors = ['.content-list', '.package-content', '.login-content', '.adult-content'];
                    const isInScrollable = scrollableSelectors.some(selector => {
                        const container = e.target.closest(selector);
                        if (container) {
                            // Check if container can scroll
                            const canScrollDown = container.scrollTop < (container.scrollHeight - container.clientHeight - 5);
                            const canScrollUp = container.scrollTop > 5;
                            // Allow natural scroll if there's room to scroll
                            if ((e.deltaY > 0 && canScrollDown) || (e.deltaY < 0 && canScrollUp)) {
                                return true;
                            }
                        }
                        return false;
                    });
                    
                    // Allow natural scrolling in scrollable containers
                    if (isInScrollable) {
                        return; // Let browser handle the scroll naturally
                    }
                    
                    e.preventDefault();
                    
                    const now = Date.now();
                    
                    // Reset accumulator if too much time passed
                    if (now - this.lastScrollTime > 300) {
                        this.scrollAccumulator = 0;
                    }
                    this.lastScrollTime = now;
                    
                    // Accumulate scroll delta
                    this.scrollAccumulator += e.deltaY;
                    
                    // Check if threshold reached
                    if (Math.abs(this.scrollAccumulator) >= this.scrollThreshold) {
                        if (this.scrollAccumulator > 0) {
                            // Scroll down - move focus down or seek forward in video
                            if (player && !player.paused()) {
                                player.currentTime(player.currentTime() + 5);
                            } else {
                                this.moveFocus('down');
                            }
                        } else {
                            // Scroll up - move focus up or seek backward in video
                            if (player && !player.paused()) {
                                player.currentTime(player.currentTime() - 5);
                            } else {
                                this.moveFocus('up');
                            }
                        }
                        this.scrollAccumulator = 0;
                    }
                    
                    // Horizontal scroll (some remotes)
                    if (Math.abs(e.deltaX) > this.scrollThreshold) {
                        if (e.deltaX > 0) {
                            this.moveFocus('right');
                        } else {
                            this.moveFocus('left');
                        }
                    }
                }, { passive: false });
            },
            
            // Setup touchpad for Apple TV Siri Remote, newer smart remotes
            setupTouchpad() {
                let touchStartX = 0;
                let touchStartY = 0;
                let touchMoved = false;
                
                document.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    touchMoved = false;
                }, { passive: true });
                
                document.addEventListener('touchmove', (e) => {
                    touchMoved = true;
                }, { passive: true });
                
                document.addEventListener('touchend', (e) => {
                    if (!touchMoved) return; // Was a tap, not swipe
                    
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;
                    
                    const minSwipeDistance = 30;
                    
                    // Determine swipe direction
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe
                        if (Math.abs(deltaX) > minSwipeDistance) {
                            if (deltaX > 0) {
                                // Swipe right
                                if (player && !player.paused()) {
                                    player.currentTime(player.currentTime() + 10);
                                } else {
                                    this.moveFocus('right');
                                }
                            } else {
                                // Swipe left
                                if (player && !player.paused()) {
                                    player.currentTime(player.currentTime() - 10);
                                } else {
                                    this.moveFocus('left');
                                }
                            }
                        }
                    } else {
                        // Vertical swipe
                        if (Math.abs(deltaY) > minSwipeDistance) {
                            if (deltaY > 0) {
                                this.moveFocus('down');
                            } else {
                                this.moveFocus('up');
                            }
                        }
                    }
                }, { passive: true });
            },
            
            // Get all focusable elements in current view
            updateFocusableElements() {
                const selectors = [
                    'button:not([disabled]):not([style*="display: none"])',
                    '.content-card',
                    '.source-tab',
                    '.package-card',
                    '.video-card',
                    'input:not([disabled])',
                    '.close-btn',
                    '[tabindex]:not([tabindex="-1"])'
                ];
                
                this.focusableElements = Array.from(
                    document.querySelectorAll(selectors.join(','))
                ).filter(el => {
                    const rect = el.getBoundingClientRect();
                    const style = window.getComputedStyle(el);
                    return rect.width > 0 && rect.height > 0 && 
                           style.display !== 'none' && 
                           style.visibility !== 'hidden';
                });
            },
            
            // Add visible focus styles for TV
            addFocusStyles() {
                if (document.getElementById('tv-focus-styles')) return;
                
                const style = document.createElement('style');
                style.id = 'tv-focus-styles';
                style.textContent = `
                    /* TV Remote Focus Styles */
                    .tv-focused,
                    *:focus {
                        outline: 3px solid #7c3aed !important;
                        outline-offset: 3px !important;
                        box-shadow: 0 0 20px rgba(124, 58, 237, 0.6) !important;
                        transform: scale(1.02);
                        transition: all 0.15s ease !important;
                    }
                    
                    .content-card.tv-focused,
                    .video-card.tv-focused,
                    .package-card.tv-focused {
                        transform: scale(1.05);
                        z-index: 100;
                    }
                    
                    .source-tab.tv-focused {
                        background: linear-gradient(135deg, #7c3aed, #a855f7) !important;
                    }
                    
                    button.tv-focused {
                        transform: scale(1.08);
                    }
                `;
                document.head.appendChild(style);
            },
            
            // Move focus in direction
            moveFocus(direction) {
                this.updateFocusableElements();
                if (this.focusableElements.length === 0) return;
                
                const current = document.activeElement;
                const currentRect = current?.getBoundingClientRect();
                
                let bestElement = null;
                let bestScore = Infinity;
                
                this.focusableElements.forEach(el => {
                    if (el === current) return;
                    
                    const rect = el.getBoundingClientRect();
                    let score = Infinity;
                    
                    switch(direction) {
                        case 'up':
                            if (rect.bottom <= currentRect?.top + 10) {
                                score = (currentRect.top - rect.bottom) + 
                                        Math.abs(rect.left - currentRect.left) * 0.5;
                            }
                            break;
                        case 'down':
                            if (rect.top >= currentRect?.bottom - 10) {
                                score = (rect.top - currentRect.bottom) + 
                                        Math.abs(rect.left - currentRect.left) * 0.5;
                            }
                            break;
                        case 'left':
                            if (rect.right <= currentRect?.left + 10) {
                                score = (currentRect.left - rect.right) + 
                                        Math.abs(rect.top - currentRect.top) * 0.5;
                            }
                            break;
                        case 'right':
                            if (rect.left >= currentRect?.right - 10) {
                                score = (rect.left - currentRect.right) + 
                                        Math.abs(rect.top - currentRect.top) * 0.5;
                            }
                            break;
                    }
                    
                    if (score < bestScore) {
                        bestScore = score;
                        bestElement = el;
                    }
                });
                
                if (bestElement) {
                    this.setFocus(bestElement);
                }
            },
            
            // Set focus on element
            setFocus(element) {
                // Remove previous focus
                document.querySelectorAll('.tv-focused').forEach(el => {
                    el.classList.remove('tv-focused');
                });
                
                // Add focus to new element
                element.classList.add('tv-focused');
                element.focus({ preventScroll: false });
                
                // Scroll into view
                element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
            },
            
            // Handle remote button press
            setupRemoteListeners() {
                document.addEventListener('keydown', (e) => {
                    // Ignore if typing in input - allow normal text editing including backspace
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName)) {
                        // Only handle navigation keys in input fields, let all others (including Backspace) work normally
                        if (!['ArrowUp', 'ArrowDown', 'Escape'].includes(e.key)) {
                            return; // Allow backspace, typing, arrow left/right for cursor movement
                        }
                    }
                    
                    switch(e.key) {
                        // Navigation - Arrow Keys
                        case 'ArrowUp':
                            e.preventDefault();
                            this.moveFocus('up');
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.moveFocus('down');
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            // If video playing, seek backward
                            if (player && !player.paused()) {
                                player.currentTime(player.currentTime() - 10);
                            } else {
                                this.moveFocus('left');
                            }
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            // If video playing, seek forward
                            if (player && !player.paused()) {
                                player.currentTime(player.currentTime() + 10);
                            } else {
                                this.moveFocus('right');
                            }
                            break;
                            
                        // Select/OK - Enter key
                        case 'Enter':
                            e.preventDefault();
                            const focused = document.querySelector('.tv-focused') || document.activeElement;
                            if (focused) {
                                focused.click();
                            }
                            break;
                            
                        // Back button - Backspace or Escape
                        case 'Backspace':
                        case 'BrowserBack':
                            e.preventDefault();
                            this.handleBack();
                            break;
                            
                        // Play/Pause
                        case ' ':  // Space bar
                        case 'MediaPlayPause':
                        case 'p':
                        case 'P':
                            if (!['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName)) {
                                e.preventDefault();
                                if (player) {
                                    player.paused() ? player.play() : player.pause();
                                }
                            }
                            break;
                            
                        // Stop
                        case 'MediaStop':
                        case 's':
                        case 'S':
                            if (!['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName)) {
                                e.preventDefault();
                                if (typeof stopStream === 'function') {
                                    stopStream();
                                }
                            }
                            break;
                            
                        // Fullscreen toggle - F key
                        case 'f':
                        case 'F':
                            if (!['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName)) {
                                e.preventDefault();
                                if (player) {
                                    player.isFullscreen() ? player.exitFullscreen() : player.requestFullscreen();
                                }
                            }
                            break;
                            
                        // Channel Up/Down (number navigation)
                        case 'ChannelUp':
                        case 'PageUp':
                            e.preventDefault();
                            this.channelUp();
                            break;
                        case 'ChannelDown':
                        case 'PageDown':
                            e.preventDefault();
                            this.channelDown();
                            break;
                    }
                    
                    // LG webOS Magic Remote specific key codes
                    // Also Samsung Tizen remote codes
                    const keyCode = e.keyCode || e.which;
                    switch(keyCode) {
                        case 461:  // LG Back button
                        case 10009: // Samsung Tizen Back
                            e.preventDefault();
                            this.handleBack();
                            break;
                        case 403:  // Red button - Stop
                            e.preventDefault();
                            if (typeof stopStream === 'function') stopStream();
                            break;
                        case 404:  // Green button - Play
                            e.preventDefault();
                            if (player && player.paused()) player.play();
                            break;
                        case 405:  // Yellow button - Pause
                            e.preventDefault();
                            if (player && !player.paused()) player.pause();
                            break;
                        case 406:  // Blue button - Fullscreen
                            e.preventDefault();
                            if (player) {
                                player.isFullscreen() ? player.exitFullscreen() : player.requestFullscreen();
                            }
                            break;
                        case 412:  // Rewind (LG/Samsung)
                        case 10232:
                            e.preventDefault();
                            if (player) player.currentTime(player.currentTime() - 30);
                            break;
                        case 417:  // Fast Forward (LG/Samsung)
                        case 10233:
                            e.preventDefault();
                            if (player) player.currentTime(player.currentTime() + 30);
                            break;
                        case 415:  // Play (LG/Samsung)
                        case 10252:
                            e.preventDefault();
                            if (player) player.play();
                            break;
                        case 19:   // Pause (LG/Samsung)
                        case 10253:
                            e.preventDefault();
                            if (player) player.pause();
                            break;
                        case 413:  // Stop (LG/Samsung)
                        case 10254:
                            e.preventDefault();
                            if (typeof stopStream === 'function') stopStream();
                            break;
                    }
                });
            },
            
            // Handle back button
            handleBack() {
                // Check for open modals
                const loginModal = document.getElementById('loginModal');
                const adultModal = document.getElementById('adultModal');
                const packageModal = document.getElementById('packageModal');
                
                if (packageModal?.classList.contains('show')) {
                    hidePackageDetails();
                } else if (adultModal?.classList.contains('show')) {
                    hideAdultModal();
                } else if (loginModal?.classList.contains('show')) {
                    hideLoginModal();
                } else if (player && player.isFullscreen()) {
                    player.exitFullscreen();
                } else if (adultUnlocked) {
                    exitAdultContent();
                }
            },
            
            // Channel navigation
            channelUp() {
                const cards = document.querySelectorAll('.content-card:not([style*="display: none"])');
                if (cards.length > 0) {
                    const currentIndex = Array.from(cards).findIndex(c => c.classList.contains('tv-focused'));
                    const prevIndex = currentIndex > 0 ? currentIndex - 1 : cards.length - 1;
                    this.setFocus(cards[prevIndex]);
                }
            },
            
            channelDown() {
                const cards = document.querySelectorAll('.content-card:not([style*="display: none"])');
                if (cards.length > 0) {
                    const currentIndex = Array.from(cards).findIndex(c => c.classList.contains('tv-focused'));
                    const nextIndex = currentIndex < cards.length - 1 ? currentIndex + 1 : 0;
                    this.setFocus(cards[nextIndex]);
                }
            }
        };
        
        // Initialize TV Remote after DOM ready
        setTimeout(() => tvRemote.init(), 500);
        
        // Re-initialize when content changes
        const contentObserver = new MutationObserver(() => {
            tvRemote.updateFocusableElements();
        });
        contentObserver.observe(document.body, { childList: true, subtree: true });
        
        // ============================================
        // END TV REMOTE CONTROL SYSTEM
        // ============================================

        // Start update system
        updateSystem.startAutoUpdateCheck();
        
        // Initialize when DOM is ready (fallback)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            // DOM is already loaded
            setTimeout(initApp, 100);
        }
    </script>
    
    <!-- OVERRIDE SCRIPT - Fix showPackageDetails subscription check -->
    <script>
    // Override showPackageDetails to fix subscription status
    window.showPackageDetails = function(packageId) {
        console.log('ðŸš€ NEW showPackageDetails v5.0 running!');
        console.log('ðŸ“¦ Opening package details for:', packageId);
        
        // Get packages data
        const packages = JSON.parse(localStorage.getItem('adminPackages') || '[]');
        const packageData = packages.find(p => p.id === packageId);
        
        if (!packageData) {
            console.error('Package not found:', packageId);
            showNotification('âŒ Package not found', 'error');
            return;
        }

        console.log('ðŸ“¦ Package data found:', packageData);

        // Get customer data using global currentUser
        const loggedInUser = (typeof currentUser !== 'undefined' && currentUser) ? currentUser.username : '';
        const customers = JSON.parse(localStorage.getItem('adminCustomers') || '[]');
        const customer = customers.find(c => c.username?.toLowerCase() === loggedInUser?.toLowerCase());
        
        console.log('ðŸ“¦ Logged in user:', loggedInUser);
        console.log('ðŸ“¦ Found customer:', customer);
        console.log('ðŸ“¦ Customer plan:', customer?.plan);
        console.log('ðŸ“¦ Customer addons:', customer?.addons);
        
        // Check if user has this package - flexible keyword matching
        const pkgName = (packageData.name || '').trim().toLowerCase();
        const customerPlan = (customer?.plan || '').toLowerCase();
        const customerAddons = (customer?.addons || '').toLowerCase();
        
        // Extract key word from package name (e.g., "movies" from "Movies Package")
        const pkgKeyword = pkgName.replace(/\s*(package|addon|content)\s*/gi, '').trim();
        
        console.log('ðŸ“¦ Package keyword:', pkgKeyword);
        console.log('ðŸ“¦ Plan includes keyword?', customerPlan.includes(pkgKeyword));
        console.log('ðŸ“¦ Addons includes keyword?', customerAddons.includes(pkgKeyword));
        
        // Check if keyword is found in plan or addons
        const hasPackage = customerPlan.includes(pkgKeyword) || customerAddons.includes(pkgKeyword);
        const isActive = hasPackage && (!customer?.expiryDate || new Date(customer.expiryDate) > new Date());
        
        console.log('ðŸ“¦ Has package:', hasPackage, '| Is active:', isActive);

        // If user has active subscription, switch directly to content tab
        if (isActive) {
            // Determine which source to switch to based on package keyword
            let targetSource = 'movies'; // default
            if (pkgKeyword.includes('adult')) {
                targetSource = 'adult';
                // Unlock adult content for this session
                adultUnlocked = true;
                // Show the adult tab
                if (typeof showAdultTab === 'function') {
                    showAdultTab();
                }
            } else if (pkgKeyword.includes('movie')) {
                targetSource = 'movies';
            }
            
            console.log('ðŸ“¦ Active subscription - switching to:', targetSource);
            console.log('ðŸ“¦ Content available:', contentData[targetSource]?.content?.length || 0, 'items');
            
            // Switch to the appropriate source tab
            if (typeof switchSource === 'function') {
                switchSource(targetSource);
                const count = contentData[targetSource]?.content?.length || 0;
                showNotification(`ðŸŽ¬ Showing ${count} items from ${packageData.name}`, 'success');
            }
            return; // Don't show modal for active subscriptions
        }

        // For non-subscribed or expired - show the package details modal
        // Update modal content
        document.getElementById('packageTitle').textContent = packageData.name;
        document.getElementById('packagePrice').textContent = packageData.price ? `$${packageData.price}/month` : 'Contact for pricing';
        document.getElementById('packageDuration').textContent = packageData.duration || 'Monthly';
        
        // Features list - handle both array and string formats
        let features = packageData.features || [];
        if (typeof features === 'string') {
            features = features.split(',').map(f => f.trim()).filter(f => f);
        }
        if (!Array.isArray(features)) {
            features = [];
        }
        const featuresHtml = features.length > 0 
            ? features.map(feature => `<div class="feature-item">âœ… ${feature}</div>`).join('')
            : '<div class="feature-item">ðŸ“‹ Features will be displayed here</div>';
        document.getElementById('packageFeatures').innerHTML = featuresHtml;
        
        // Description
        document.getElementById('packageDescription').textContent = packageData.description || 'Package description will be displayed here';
        
        // Status
        const statusElement = document.getElementById('packageStatus');
        if (hasPackage) {
            statusElement.innerHTML = '<span class="status-expired">âš ï¸ Subscription Expired</span>';
            statusElement.className = 'package-status status-expired';
        } else {
            statusElement.innerHTML = '<span class="status-inactive">ðŸ“¦ Not Subscribed - Contact Admin</span>';
            statusElement.className = 'package-status status-inactive';
        }
        
        // Show modal
        document.getElementById('packageModal').classList.add('show');
        console.log('ðŸ“¦ Package modal opened successfully');
    };
    console.log('âœ… showPackageDetails function overridden with v5.0');
    </script>
    
    <!-- Update Notification Styles -->
    <style>
        .update-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #0057FF, #0073FF);
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 87, 255, 0.3);
            transform: translateX(400px);
            transition: all 0.3s ease;
            z-index: 9999;
            max-width: 400px;
            min-width: 350px;
            font-family: 'Arial', sans-serif;
        }
        
        .update-notification.show {
            transform: translateX(0);
        }
        
        .update-content {
            padding: 20px;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .update-icon {
            font-size: 24px;
            margin-top: 5px;
        }
        
        .update-info {
            flex: 1;
        }
        
        .update-info h3 {
            margin: 0 0 5px 0;
            font-size: 16px;
            font-weight: 600;
        }
        
        .update-info p {
            margin: 0 0 5px 0;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .update-description {
            font-size: 12px;
            opacity: 0.7;
            line-height: 1.4;
        }
        
        .update-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .btn-update, .btn-dismiss {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-update {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-update:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .btn-dismiss {
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-dismiss:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .update-success {
            text-align: center;
            padding: 30px 20px;
        }
        
        .success-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .update-success h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        .update-success p {
            margin: 0;
            opacity: 0.8;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .update-notification {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                min-width: auto;
            }
        }
    </style>
    <!-- Auto-sync enabled - no manual sync UI needed for customers -->
    <!-- Data syncs automatically on app startup from configured URL -->
</body>
</html>